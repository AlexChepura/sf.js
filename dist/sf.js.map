{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/es6-promise/dist/es6-promise.js","node_modules/process/browser.js","src/core/Ajax.js","src/core/BaseDOMConstructor.js","src/core/DomMutations.js","src/core/Events.js","src/core/InstancesController.js","src/core/ajax/baseActions.js","src/core/events/baseEvents.js","src/helpers/DOMEvents.js","src/helpers/LikeFormData.js","src/helpers/domTools.js","src/helpers/tools.js","src/index.js","src/sf.js","src/shim/Object.assign.js","src/shim/console.js"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sf.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   3.3.1\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  return typeof x === 'function' || typeof x === 'object' && x !== null;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (!Array.isArray) {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n} else {\n  _isArray = Array.isArray;\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  return function () {\n    vertxNext(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = r('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  _resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        _resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      _reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      _reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    _reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return _resolve(promise, value);\n    }, function (reason) {\n      return _reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$) {\n  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$ === GET_THEN_ERROR) {\n      _reject(promise, GET_THEN_ERROR.error);\n    } else if (then$$ === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$)) {\n      handleForeignThenable(promise, maybeThenable, then$$);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction _resolve(promise, value) {\n  if (promise === value) {\n    _reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction _reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      _reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      _resolve(promise, value);\n    } else if (failed) {\n      _reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      _reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      _resolve(promise, value);\n    }, function rejectPromise(reason) {\n      _reject(promise, reason);\n    });\n  } catch (e) {\n    _reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this._input = input;\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate();\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    _reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n};\n\nEnumerator.prototype._enumerate = function () {\n  var length = this.length;\n  var _input = this._input;\n\n  for (var i = 0; this._state === PENDING && i < length; i++) {\n    this._eachEntry(_input[i], i);\n  }\n};\n\nEnumerator.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$ = c.resolve;\n\n  if (resolve$$ === resolve) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$) {\n        return resolve$$(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$(entry), i);\n  }\n};\n\nEnumerator.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      _reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  _reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = resolve;\nPromise.reject = reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\nPromise.prototype = {\n  constructor: Promise,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nfunction polyfill() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise;\n}\n\npolyfill();\n// Strange compat..\nPromise.polyfill = polyfill;\nPromise.Promise = Promise;\n\nreturn Promise;\n\n})));\n//# sourceMappingURL=es6-promise.map","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\"use strict\";\r\n\r\nvar tools = require(\"../helpers/tools\");\r\nvar Events = require(\"../core/Events\");\r\nvar LikeFormData = require(\"../helpers/LikeFormData\");\r\n/**\r\n * This is an Ajax transport.\r\n * Supports  XDomainRequest for old IE\r\n * @param {Object} [options]\r\n * @param {Object} [options.headers] Headers to add to the instance\r\n * @fires beforeSend event that will be performed before request is send. Event called with one parameter \"options\", that contains all variables for Ajax\r\n * @constructor\r\n */\r\nvar Ajax = function (options) {\r\n    this.currentRequests = 0;\r\n    this.events = new Events([\"beforeSend\", 'load']);\r\n\r\n    if (options && options.headers) {\r\n        this.headers = Object.assign(this.headers, options.headers);\r\n    }\r\n};\r\n\r\n/**\r\n * Default headers. You can overwrite it. Look at the event beforeSend\r\n * Please note that on XDomainRequest  we can't send any headers.\r\n * @type Object\r\n */\r\nAjax.prototype.headers = {\r\n    'X-Requested-With': 'XMLHttpRequest'\r\n};\r\n\r\n/**\r\n * Send ajax request to server\r\n * Will return promise or array with promise and XMLHttpRequest : {window.Promise|[window.Promise,XMLHttpRequest]}\r\n * @since 0.4.0\r\n * @param {Object} options object with options\r\n * @param {String} options.url url to send data\r\n * @param {Object|String} [options.data] data to send\r\n * @param {String} [options.method]\r\n * @param {Object} [options.headers] headers to add to the request\r\n * @param {Function} [options.onProgress] callback function on progress. Two callback options: current bytes sent,totalBytes\r\n * @param {Function} [options.isReturnXHRToo===false] should method return array instead of Promise. Some times is needed to control ajax (abort, etc). If tree then  [window.Promise,XMLHttpRequest ] will be returned\r\n * @returns {Promise|Array}\r\n */\r\nAjax.prototype.send = function (options) {\r\n    var that = this;\r\n\r\n    //TODO why we check here if data === null then reassign to null again?\r\n    if (options.data === null || options.data === void 0 || options.data === 'undefined') {\r\n        options.data = null;\r\n    }\r\n    if (!options.method) {\r\n        options.method = \"POST\"\r\n    }\r\n\r\n    options.headers = options.headers ? Object.assign(options.headers, this.headers, options.headers) : Object.assign({}, this.headers);\r\n    var xhr;\r\n    var ajaxPromise =  new Promise(function (resolve, reject) {    // Return a new promise.\r\n        if (!options.url) {\r\n            console.error(\"You should provide url\");\r\n            reject(\"You should provide url\");\r\n        }\r\n        that.currentRequests++;\r\n\r\n        var oldIE = false;\r\n\r\n        if ((typeof window !== 'undefined') && window.XDomainRequest && (window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined) && (url.indexOf(\"http\") === 0)) {//old IE CORS\r\n            //TODO maybe we should use XDomainRequest only for cross domain requests? But  Spiral for now works great with XDomainRequest (based on IEJSON)\r\n            xhr = new XDomainRequest();\r\n            //http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\r\n            oldIE = true;\r\n            //http://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment\r\n            xhr.onprogress = function (e) {\r\n                //TODO adjust options\r\n                options.onProgress && options.onProgress(e);\r\n            };\r\n        } else {\r\n            xhr = new XMLHttpRequest();\r\n            if (options.onProgress) {\r\n                xhr.upload.addEventListener(\"progress\", function (event) {\r\n                    if (event.lengthComputable) {\r\n                        options.onProgress(event.loaded, event.total);\r\n                    }\r\n                }, false);\r\n            }\r\n\r\n        }\r\n\r\n\r\n        xhr.open(options.method, options.url);\r\n\r\n        xhr.onload = function () {//On loaded\r\n            that.currentRequests--;\r\n            var ans = that._parseJSON(xhr);\r\n            if (ans.status) {\r\n                if (ans.status > 199 && ans.status < 300) {//200-299\r\n                    resolve(ans);\r\n                } else if (ans.status > 399 && ans.status < 600) {//400-599\r\n                    reject(ans);\r\n                } else {\r\n                    console.error(\"unknown status %d. Rejecting\", ans.status);\r\n                    reject(ans);\r\n                }\r\n\r\n            } else if (oldIE) {\r\n                resolve(ans);//OLD IE + downloading file is producing  no status.\r\n            } else {\r\n                reject(ans);//reject with the status text\r\n            }\r\n            options.response = ans;\r\n            that.events.trigger(\"load\", options);//for example - used to handle actions\r\n        };\r\n        xhr.onerror = function () {// Handle network errors\r\n            that.currentRequests--;\r\n            reject(Error(\"Network Error\"), xhr);\r\n        };\r\n\r\n        that.events.trigger(\"beforeSend\", options);//you can modify \"options\" object inside event (like adding you headers,data,etc)\r\n\r\n        var dataToSend;\r\n        if (options.data !== null) {//if data to send is not empty\r\n            if (!oldIE) {\r\n                if (options.data.toString().indexOf(\"FormData\") !== -1) {//if form data\r\n                    dataToSend = options.data;\r\n                } else {\r\n                    dataToSend = new LikeFormData(options.data);\r\n                    options.headers[\"content-type\"] = dataToSend.getContentTypeHeader();\r\n                }\r\n                that._setHeaders(xhr, options.headers);\r\n\r\n            } else {\r\n                dataToSend = \"IEJSON\" + JSON.stringify(options.data);\r\n            }\r\n        } else {//else send empty data\r\n            dataToSend = null;\r\n        }\r\n\r\n\r\n//        if (!oldIE) {\r\n//            //xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\r\n//            dataToSend = new spiral.LikeFormData(data, xhr, oldIE);\r\n//        } else {\r\n//            if (data !==null && data !== void 0 && data !== 'undefined'){\r\n//                dataToSend = \"IEJSON\"+JSON.stringify(data);\r\n//            } else {\r\n//                 dataToSend =data;\r\n//            }\r\n//\r\n//        }\r\n\r\n\r\n        try {//working around FF bug\r\n            xhr.send(dataToSend);// Make the request\r\n        } catch (e) {\r\n            //console.error(\"error sending trying another method\");\r\n            xhr.send(dataToSend.toString());\r\n        }\r\n\r\n        return xhr;\r\n    });\r\n\r\n    if (options.isReturnXHRToo){//return xhr too\r\n        return [ajaxPromise,xhr]\r\n    }\r\n    return ajaxPromise;\r\n};\r\n\r\n/**\r\n * Iterate over headers object and call xhr.setRequestHeader\r\n * @param {XMLHttpRequest} xhr\r\n * @param {Object} headers object with headers to set\r\n */\r\nAjax.prototype._setHeaders = function (xhr, headers) {\r\n    for (var header in headers) {\r\n        xhr.setRequestHeader(header, headers[header]);\r\n    }\r\n\r\n};\r\n/**\r\n * Try to parse and normalize answer\r\n * @param xhr\r\n * @returns {*}\r\n * @private\r\n */\r\nAjax.prototype._parseJSON = function (xhr) {\r\n    if (!xhr.response) {\r\n        xhr.response = xhr.responseText;\r\n    }\r\n    var ret = {};\r\n    var contentType = false;\r\n    if (xhr.getResponseHeader) {\r\n        contentType = xhr.getResponseHeader(\"Content-Type\");\r\n    }\r\n\r\n    if (!contentType || contentType.toLowerCase() === 'application/json' || contentType.toLowerCase() === 'text/json' || contentType.toLowerCase() === 'inode/symlink') {//application/json or inode/symlink  (AmazonS3 bug? )\r\n        try {\r\n            ret = JSON.parse(xhr.response);\r\n        } catch (e) {\r\n            console.error(\"Not a JSON!\", xhr.response);\r\n            ret = {data: xhr.response};\r\n        }\r\n    } else {\r\n        ret = {data: xhr.response};\r\n    }\r\n\r\n    if (!ret.status) {\r\n        ret.status = xhr.status;\r\n    }\r\n    //Some servers can answer status in JSON as \"HTTP/1.1 200 OK\"  but we need a status number\r\n    if (typeof ret.status === 'string' && ret.status.indexOf(\"HTTP/\") === 0 && ret.status.match( / (\\d\\d\\d)/ )) {\r\n        ret.status = parseInt(ret.status.match( / (\\d\\d\\d)/ )[1]);//TODO check this code\r\n    }\r\n\r\n\r\n    if (!ret.statusText) {\r\n        ret.statusText = xhr.statusText;\r\n    }\r\n    if (xhr.status && xhr.status != ret.status) {\r\n        console.warn(\"Status from request %d, but response contains status %d\", xhr.status, ret.status)\r\n    }\r\n\r\n    return ret;\r\n\r\n};\r\n\r\n\r\nmodule.exports = Ajax;\r\n","\"use strict\";\r\n\r\n/**\r\n * This a base constructor (class) for any DOM based instance.\r\n * This constructor just grab all node attributes and generates options. All processed options stored at this.options\r\n * @example\r\n * We have html like this:\r\n * <div data-test=\"testValue\" data-value=\"value123\">.....</div>\r\n * this.options will be:\r\n * {\r\n *  test:\"testValue\",\r\n *  value:\"value\"\r\n * }\r\n * Note: data-test and data-value should be described in attributesToGrab\r\n * @constructor\r\n */\r\nvar BaseDOMConstructor = function () {\r\n};\r\n/**\r\n * Init method. Call after construct instance\r\n * @param {Object} sf\r\n * @param {Object} node  DomNode of form\r\n * @param {Object} [options] all options to override default\r\n */\r\nBaseDOMConstructor.prototype.init = function (sf, node, options) {\r\n    //TODO data-spiral-JSON\r\n    this.sf = sf;\r\n    this.node = node;\r\n    //if (sf.options && sf.options.instances && sf.options.instances[this.name]) {\r\n    //    options = Object.assign(options || {}, sf.options.instances[this.name]);\r\n    //}\r\n    this.options = Object.assign(this.grabOptions(node), options);\r\n};\r\n\r\n/**\r\n * This is a options to generate.\r\n * You should provide processor or value.\r\n * @type {Object}\r\n * @property {Object} propertyKey - object of property\r\n * @property {String} propertyKey.value - default value to return\r\n * @property {String} [propertyKey.domAttr] - dom attribute to grab data\r\n * @property {Function} [propertyKey.processor] -  processor to process data before return\r\n * @property {Object}  ... - Another object of one property\r\n * @type {{}}\r\n *  @example\r\n * \"someAttribute\": {// key\r\n *      value: true, //default Value\r\n *      domAttr: \"data-some-attribute\", // attribute from node to grab\r\n *      processor: function (node,val,self) { //processor to process values before return\r\n *          //some calculations\r\n *      return someValue;\r\n *      }\r\n *  },\r\n *  \"anotherAttribute\":{...},\r\n *  \"...\"\r\n *\r\n *  @example\r\n *  //return node as value\r\n *  \"context\": {\r\n *      \"processor\": function (node,val,key) { //processor\r\n *          return node;\r\n *      }\r\n *  },\r\n *  \"Another-key\":{...},\r\n *  \"...\"\r\n * @example\r\n * //Grab attribute \"data-attribute\" as \"MyAttribute\" if attribute not provided return \"DefaultValue\"\r\n * // Dom node <div data-attribute=\"someValue\"></div>\r\n * \"MyAttribute\": {\r\n *      value: \"DefaultValue\",\r\n *      domAttr: \"data-attribute\"\r\n *  }\r\n *  //after processing we should have\r\n *  {\"MyAttribute\":\"someValue\"}\r\n *\r\n *  @example\r\n * //Grab attribute \"data-attribute\" as \"MyAttribute\" and return some value instead\r\n * //Dom node  <div data-attribute=\"someValue\"></div>\r\n * \"MyAttribute\": {\r\n *      domAttr: \"data-attribute\",\r\n *      processor: function (node,val,self) {\r\n *          return val+\"SomeCalculation\";\r\n *      }\r\n *  }\r\n *  //after processing we should have\r\n *  {\"MyAttribute\":\"someValueSomeCalculation\"}\r\n *\r\n * @example\r\n * //return function as value\r\n * processAnswer: {\r\n *      \"value\": function (options) {\r\n *         return \"someVal\";\r\n *      }\r\n *  //after processing we should have\r\n *  {\"processAnswer\":function (options) {\r\n *         return \"someVal\";\r\n *      }\r\n *   }\r\n *\r\n * @example\r\n * //return init time as value\r\n * initTime: {\r\n *      \"processor\": function (node,val,self) {\r\n *         return new Date().getTime;\r\n *      }\r\n *  //after processing we should have\r\n *  {\"initTime\":1429808977404}\r\n * @example\r\n * //return other value instead of real one\r\n * processAnswer: {\r\n *      \"processor\": function (node,val,self) {\r\n *         return \"someVal\";\r\n *      }\r\n *  //after processing we should have\r\n *  {\"processAnswer\":\"someVal\"}\r\n */\r\nBaseDOMConstructor.prototype.optionsToGrab = {};\r\n\r\n/**\r\n * Grab all options that described in optionsToGrab\r\n * @param {Object} node domNode\r\n * @return {Object}\r\n */\r\nBaseDOMConstructor.prototype.grabOptions = function (node) {\r\n    var options = {};\r\n    var currentOptionValue;\r\n    var currentOption;\r\n    for (var option in this.optionsToGrab) {\r\n        currentOptionValue = null;\r\n        if (this.optionsToGrab.hasOwnProperty(option)) {//if this is own option\r\n            currentOption = this.optionsToGrab[option];\r\n            if (currentOption.hasOwnProperty(\"value\")) {//we have default option. Let's grab it for first\r\n                currentOptionValue = currentOption.value;\r\n            }\r\n\r\n            if (this.sf.options.instances[this.name] && this.sf.options.instances[this.name].hasOwnProperty(option)) {\r\n                currentOptionValue = this.sf.options.instances[this.name][option]\r\n            }\r\n\r\n            if (currentOption.hasOwnProperty(\"domAttr\") && node.attributes.hasOwnProperty(currentOption.domAttr)) {//we can grab the attribute of node\r\n                currentOptionValue = node.attributes[currentOption.domAttr].value;\r\n            }\r\n\r\n            if (currentOption.hasOwnProperty(\"processor\")) {//we have processor. Let's execute it\r\n                currentOptionValue = currentOption.processor.call(this, node, currentOptionValue, currentOption);\r\n            }\r\n\r\n            if (currentOptionValue !== null) {\r\n                options[option] = currentOptionValue;\r\n            }\r\n\r\n        }\r\n    }\r\n    return options;\r\n};\r\n\r\n/**\r\n * Get addon for instance\r\n * @param {String} addonType type of addon (message,fill,etc)\r\n * @param {String} addonName name of addon\r\n */\r\n//depricated\r\n//BaseDOMConstructor.prototype.getAddon = function (addonType, addonName) {\r\n//    return this.spiral.instancesController.getInstanceAddon(this.name, addonType, addonName);\r\n//};\r\n\r\nmodule.exports = BaseDOMConstructor;\r\n","\"use strict\";\r\n/**\r\n * Dom mutation. Listening to the DOM and add or remove instances based on classes.\r\n * @param {Object} instancesController  spiral instancesController.\r\n * @param {Function} instancesController.getClasses  get all registered modules classes.\r\n * @param {Function} instancesController.addInstance  add instance method.\r\n * @param {Function} instancesController.removeInstance  remove instance method\r\n * @constructor\r\n */\r\nvar DomMutations = function (instancesController) {\r\n    if (!instancesController){\r\n        console.error(\"You should provide instancesController  for DOM Mutation. Because DOM Mutation  should known all classes and\");\r\n        return;\r\n    }\r\n    if (!this.constructor){\r\n        console.error(\"Please call DomMutations with new  - 'new DomMutations()' \");\r\n        return;\r\n    }\r\n    this.instancesController = instancesController;\r\n    var config = {//config for MutationObserver\r\n            attributes: true,\r\n            childList: true,\r\n            characterData: true,\r\n            characterDataOldValue: true,\r\n            subtree: true,\r\n            attributeOldValue: true,\r\n            attributeFilter: [\"class\"]\r\n        },\r\n        that = this;\r\n    this.observer = new MutationObserver(function () {//call function when dom mutated.\r\n        that.onDomMutate.apply(that, arguments)\r\n    });\r\n    this.observer.observe(document, config);//start observer\r\n\r\n};\r\n/**\r\n * When dom mutated this function id executed.\r\n * @param {Array} mutations array of mutations\r\n * @returns {boolean}\r\n */\r\nDomMutations.prototype.onDomMutate = function (mutations) {\r\n    var classArray = this.instancesController.getClasses();//get all registered classes\r\n    var classSelector = \".\" + classArray.join(\",.\");//convert for querySelectorAll()\r\n    if (classSelector.length === 1) {//if not registered any instanceTypes\r\n        return false;\r\n    }\r\n    mutations.forEach(function (mutation) {//loop over mutation array\r\n        switch (mutation.type) {\r\n            case \"attributes\":\r\n                this.processMutationAttributes(mutation, classArray);\r\n                break;\r\n\r\n            case \"characterData\":\r\n\r\n                break;\r\n\r\n            case \"childList\":\r\n                this.processMutationChildList(mutation.addedNodes, \"addInstance\", classSelector, classArray);\r\n                this.processMutationChildList(mutation.removedNodes, \"removeInstance\", classSelector, classArray);\r\n                break;\r\n\r\n            case \"default\":\r\n                console.error(\"Something wrong. Contact tech support\");\r\n        }\r\n    }, this);\r\n    return true;\r\n};\r\n\r\n\r\n\r\nDomMutations.prototype.processMutationAttributes = function (mutation, classArray) {\r\n    var that = this;\r\n    var currentClasses = mutation.target.className.split(\" \"),\r\n        oldClasses = (mutation.oldValue)?mutation.oldValue.split(\" \"):[],\r\n        addedClasses = currentClasses.filter(function (val) {\r\n            return (oldClasses.indexOf(val) === -1);\r\n        }),\r\n        removedClasses = oldClasses.filter(function (val) {\r\n            return (currentClasses.indexOf(val) === -1);\r\n        }),\r\n        addedRegisteredClasses = addedClasses.filter(function (val) {\r\n            return (classArray.indexOf(val) !== -1);\r\n        }),\r\n        removedRegisteredClasses = removedClasses.filter(function (val) {\r\n            return (classArray.indexOf(val) !== -1);\r\n        });\r\n    removedRegisteredClasses.forEach(function (val) {\r\n        that.instancesController.removeInstance(that.instancesController.getInstanceNameByCssClass(val), mutation.target);\r\n    });\r\n    addedRegisteredClasses.forEach(function (val) {\r\n        that.instancesController.addInstance(that.instancesController.getInstanceNameByCssClass(val), mutation.target);\r\n    });\r\n\r\n};\r\n/**\r\n * Process mutation on ChildList\r\n * @param {NodeList} nodesList array with nodes\r\n * @param {String} action action to call (add or remove nodes)\r\n * @param {String} classSelector - string selector for querySelectorAll\r\n * @param {Array} classArray - array of all registered classes\r\n */\r\nDomMutations.prototype.processMutationChildList = function (nodesList, action, classSelector, classArray) {\r\n    var that =this;\r\n    /**\r\n     * Internal function for checking node class\r\n     * @param {Object} node dom node\r\n     */\r\n    function checkNode(node) {\r\n        classArray.forEach(function (className) {//loop over registered classes\r\n            if (node.classList.contains(className)) {//if class match try to add or remove instance for this node\r\n                that.instancesController[action](that.instancesController.getInstanceNameByCssClass(className), node);\r\n            }\r\n        });\r\n    }\r\n\r\n    [].forEach.call(nodesList, function (val) {//loop over mutation nodes\r\n        if (val.nodeType !== 1 || val.nodeName === \"SCRIPT\" || val.nodeName === \"LINK\") {//do not process other nodes then ELEMENT_NODE https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType also ignore SCRIPT and LINK tag\r\n            return false;\r\n        }\r\n        checkNode(val);//check mutation node\r\n        [].forEach.call(val.querySelectorAll(classSelector), checkNode);//query all nodes with required classes and check it\r\n        return true;\r\n    });\r\n\r\n};\r\n\r\n/**\r\n * Stop listening the dom changes\r\n */\r\nDomMutations.prototype.stopObserve = function () {\r\n    this.observer.disconnect();\r\n};\r\n\r\nmodule.exports = DomMutations;\r\n\r\n\r\n","\"use strict\";\r\n\r\n/**\r\n * Events system.\r\n * @param {Array} allowedEvents array of allowed events.\r\n * @constructs Events\r\n * @example\r\n * //allow to work with all events\r\n * var events = new Events();\r\n * events.on(\"myBestEvent\",function(e){console.log(e)});\r\n * @example\r\n * //Allow to serve only limited events\r\n *  var events = new Events([\"beforeSubmit\",\"onDataReady\"]);\r\n *  events.on(\"myBestEvent\",function(e){console.log(e)});//will not works\r\n *  events.on(\"beforeSubmit\",function(e){console.log(e)});//will work\r\n */\r\nvar Events = function (allowedEvents) {\r\n    this._storage = {};\r\n    this._allowedEvents = allowedEvents;\r\n};\r\n\r\n/**\r\n * Add event(s)\r\n * @param {String} events event or space separated event list\r\n * @param {Function} callback callback function\r\n * @example\r\n * var events = new Events();\r\n * events.on(\"myBestEvent myBestEvent2 myBestEvent3\",function(e){console.log(e)});\r\n * events.on(\"myBestEvent\",function(e){console.log(e)});\r\n */\r\nEvents.prototype.on = function (events, callback) {\r\n    var eventArr = events.replace(/\\s{2,}/g, \" \").split(\" \");\r\n    eventArr.forEach(function(event){\r\n        if (this._allowedEvents  && this._allowedEvents.indexOf(event) === -1){// event not inside allowed events\r\n            console.warn(\"Events. Try to register event %s, but event is not allowed\",event);\r\n            return;\r\n        }\r\n        if (!this._storage.hasOwnProperty(events)) {\r\n            this._storage[event] = [];\r\n        }\r\n        this._storage[event].push(callback);\r\n    },this)\r\n\r\n};\r\n/**\r\n * Add action\r\n * @param {String} action\r\n * @param {Function} func\r\n * @deprecated  use \"on\" instead\r\n */\r\nEvents.prototype.registerAction = Events.prototype.on;\r\n\r\n\r\n/**\r\n * remove event\r\n * @param {String} event\r\n * @param {Function} callback\r\n */\r\nEvents.prototype.off = function (event, callback) {\r\n    alert(\"You try to remove action. This part is incomplete\");\r\n    //TODO\r\n};\r\n\r\n/**\r\n * Trigger event.\r\n * @param {String} event event name\r\n * @param {Object} [options] options to pass to the callback\r\n * @example\r\n * var events = new Events();\r\n * events.on(\"myBestEvent\",function(e){console.log(e.bestKey)});\r\n * events.trigger(\"myBestEvent\",{bestKey:42}); //will show in log\r\n */\r\nEvents.prototype.trigger = function (event, options) {\r\n    if (this._allowedEvents  && this._allowedEvents.indexOf(event) === -1){// event not inside allowed events\r\n        console.warn(\"Events. Try to trigger event %s, but event is not allowed\",event);\r\n        return;\r\n    }\r\n    if (this._storage.hasOwnProperty(event)) {\r\n        for (var n = 0, l = this._storage[event].length; n < l; n++) {\r\n            this._storage[event][n](options);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Perform action\r\n * @param {String} action\r\n * @param {Object} [actionParams] object with all action data from server\r\n * @param {Object} [options] ajax options\r\n * @deprecated use \"trigger\" instead\r\n */\r\nEvents.prototype.performAction = Events.prototype.trigger;\r\n\r\nmodule.exports = Events;","\"use strict\";\r\n\r\n/**\r\n * Instance controller\r\n * @param spiral\r\n * @constructor\r\n */\r\nvar InstancesController = function (spiral) {\r\n    this.spiral = spiral;\r\n    if (!this.constructor){\r\n        console.error(\"Please call InstancesController with new  - 'new InstancesController()' \");\r\n        return;\r\n    }\r\n    this._storage = {\r\n        instancesConstructors: {\r\n            cssClasses:{},\r\n            jsConstructors:{}\r\n        },\r\n        addons: {},\r\n        instances: {}\r\n    };\r\n\r\n    //todo decide if we need this\r\n    //[\"onAddInstance\", \"onRemoveInstance\"]\r\n    //this.events = new spiral.modules.core.Events();\r\n};\r\n/**\r\n * Register new instance type\r\n * @param {Function} constructorFunction - constructor function of instance\r\n * @param {String} [cssClassName] - css class name of instance. If class not provided that it can't be automatically controlled by DomMutation. But you still can use it from JS.\r\n * @param {Boolean} [isSkipInitialization=false]  - skip component initialization, just adding, no init nodes.\r\n */\r\nInstancesController.prototype.registerInstanceType = function (constructorFunction, cssClassName, isSkipInitialization) {\r\n    var instanceName = constructorFunction.prototype.name;\r\n\r\n    if (!instanceName){\r\n        console.error(\"Instance constructor should have name inside it\");\r\n    }\r\n\r\n    if (this._storage.instancesConstructors.jsConstructors.hasOwnProperty(instanceName)){\r\n        console.error(\"Instance Constructor for type '%s' already added. Skipping\",instanceName);\r\n        return;\r\n    }\r\n\r\n    if (cssClassName){//add link (cssClassName->instanceName)\r\n        this._storage.instancesConstructors.cssClasses[cssClassName] = instanceName;\r\n    }\r\n\r\n    this._storage.instancesConstructors.jsConstructors[instanceName] = constructorFunction;\r\n\r\n\r\n\r\n    // if (this._storage.instancesConstructors.hasOwnProperty(className)){\r\n    //    console.error(\"Instance Constructor for type %s already added. Skipping\",constructorFunction.prototype.name);\r\n    //    return;\r\n    //}\r\n    //this._storage.instancesConstructors[className] = {//init storage fields\r\n    //    \"typeName\": constructorFunction.prototype.name,\r\n    //    \"constructor\": constructorFunction\r\n    //};\r\n    this._storage.instances[instanceName] = [];\r\n    if (!isSkipInitialization){\r\n        var nodes = document.getElementsByClassName(cssClassName);//init add nodes with this class\r\n        for (var i = 0, max = nodes.length; i < max; i++) {\r\n            this.addInstance(instanceName, nodes[i]);\r\n        }\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Old method to register instance type\r\n * @param className\r\n * @param constructorFunction\r\n * @param isSkipInitialization\r\n * @deprecated\r\n */\r\nInstancesController.prototype.addInstanceType =function(className,constructorFunction, isSkipInitialization){\r\n    console.warn(\"addInstanceType is deprecated. Please use registerInstanceType instead\");\r\n    return this.registerInstanceType(constructorFunction, isSkipInitialization);\r\n};\r\n\r\n\r\n/**\r\n * Add instance\r\n * @param {String} instanceName - name of instance\r\n * @param {Object} node - dom node\r\n * @param {Object} [options] all options for send to the constructor\r\n * @returns {boolean}\r\n */\r\nInstancesController.prototype.addInstance = function (instanceName, node, options) {\r\n    var instanceConstructor = this._storage.instancesConstructors.jsConstructors[instanceName],\r\n        isAlreadyAdded = this.getInstance(instanceName,node);\r\n    if (!instanceConstructor || isAlreadyAdded) {//if not found this type  or already added - return\r\n        return false;\r\n    }\r\n//    console.log(\"Adding instance for type -\",instanceName,\". Node - \",node);\r\n    var instance = new instanceConstructor(this.spiral,node, options);\r\n    this._storage.instances[instanceName].push({//add new instance of this type\r\n        \"node\": node,\r\n        \"instance\": instance\r\n    });\r\n\r\n    //this.events.trigger(\"onAddInstance\", instance);\r\n\r\n    return instance;\r\n};\r\n/**\r\n * Remove instance.\r\n * @param {String} instanceName - name of instance class\r\n * @param {Object|String} node - dom node ID\r\n * @returns {boolean}\r\n */\r\nInstancesController.prototype.removeInstance = function (instanceName, node) {\r\n    var instanceObj = this.getInstance(instanceName, node,true),\r\n        key;\r\n    if (!instanceObj) {\r\n        return false;\r\n    }\r\n    instanceObj.instance.die();//avoid memory leak\r\n    key = this._storage.instances[instanceName].indexOf(instanceObj);\r\n    if (key !== -1){//remove key\r\n        this._storage.instances[instanceName].splice(key, 1);\r\n    }\r\n    return true;\r\n};\r\n/**\r\n * Get instance. Return instance object of this dom node\r\n * @param {String} instanceName - name of instance\r\n * @param {Object|String} node - dom node o dome node ID\r\n * @param {boolean} [isReturnObject] - return object or instance\r\n * @returns {boolean}\r\n */\r\nInstancesController.prototype.getInstance = function (instanceName, node, isReturnObject) {//TODO isReturnObject not needed. Refactor and remove\r\n    var typeArr = this._storage.instances[instanceName],\r\n        ret = false;\r\n    if (!typeArr) {\r\n        return false;\r\n    }\r\n    node = (node instanceof HTMLElement) ? node : document.getElementById(node);\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    for (var key = 0, l = typeArr.length; key < l; key++) {//iterate storage and try to find instance\r\n        if (typeArr[key].node === node) {\r\n            ret = (isReturnObject) ? typeArr[key] : typeArr[key].instance;\r\n            break;\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Get instances. Return array of instances objects\r\n * @param {String} instanceName - name of instance\r\n * @returns {array|boolean}\r\n */\r\nInstancesController.prototype.getInstances = function (instanceName) {\r\n    return this._storage.instances[instanceName] || false;\r\n};\r\n\r\n\r\n/**\r\n * Register addon for instance\r\n * @param {Function|Object} addon\r\n * @param {String} instanceName name of instance to register addon\r\n * @param {String} addonType type of addon (message,fill,etc)\r\n * @param {String} addonName name of addon (spiral, bootstrap,etc)\r\n */\r\nInstancesController.prototype.registerAddon = function(addon, instanceName, addonType, addonName){\r\n    if (!this._storage.addons.hasOwnProperty(instanceName)){\r\n        this._storage.addons[instanceName] = {};\r\n    }\r\n    if (!this._storage.addons[instanceName].hasOwnProperty(addonType)){\r\n        this._storage.addons[instanceName][addonType] = {};\r\n    }\r\n    if (this._storage.addons[instanceName][addonType].hasOwnProperty(addonName)){\r\n        console.error(\"The %s addon type %s already registered for instance %s! Skipping registration.\",addonName,addonType,instanceName);\r\n        return;\r\n    }\r\n    this._storage.addons[instanceName][addonType][addonName]= addon;\r\n\r\n};\r\n\r\n/**\r\n * Get registered addon\r\n * @param {String} instanceName name of instance to register addon\r\n * @param {String} addonType type of addon (message,fill,etc)\r\n * @param {String} addonName name of addon (spiral, bootstrap,etc)\r\n */\r\nInstancesController.prototype.getInstanceAddon =function(instanceName, addonType, addonName){\r\n    if (!this._storage.addons.hasOwnProperty(instanceName) || !this._storage.addons[instanceName].hasOwnProperty(addonType) || !this._storage.addons[instanceName][addonType].hasOwnProperty(addonName)){\r\n        return false;\r\n    }\r\n    return this._storage.addons[instanceName][addonType][addonName];\r\n};\r\n\r\n\r\n/**\r\n * Get all registered classes\r\n * @returns {Array}\r\n */\r\nInstancesController.prototype.getClasses = function (){\r\n    return Object.keys(this._storage.instancesConstructors.cssClasses);\r\n};\r\n\r\n/**\r\n * For given cssClass return name of instance\r\n * @param {String} cssClass\r\n * @return {*}\r\n */\r\nInstancesController.prototype.getInstanceNameByCssClass = function(cssClass){\r\n    return this._storage.instancesConstructors.cssClasses[cssClass];\r\n};\r\n\r\n/**\r\n * Get constructor by name or class name\r\n */\r\nInstancesController.prototype.getInstanceConstructors = function (name){\r\n\r\n   //TODO\r\n};\r\n\r\nmodule.exports = InstancesController;\r\n","\"use strict\";\r\n\r\n/**\r\n * This plugin adds ability to perform actions from the server.\r\n * \"action\":\"reload\"\r\n * \"action\":{\"redirect\":\"/account\"}\r\n * \"action\":{\"redirect\":\"/account\",\"delay\":3000}\r\n * \"action\":{\"name\":\"redirect\",\"url\":\"/account\",\"delay\":3000}\r\n */\r\nmodule.exports = function (sf) {\r\n    sf.ajax.events.on('load', function (options) {\r\n        var response = options.response;\r\n        if (response.hasOwnProperty('action')) {\r\n            if (typeof response.action === 'string') {//\"action\":\"reload\"\r\n                sf.events.trigger(response.action);\r\n            } else if (typeof response.action === 'object') {\r\n                var keys = Object.keys(response.action);\r\n                if (keys.indexOf('flash') !== -1){\r\n                    var flash = response.action['flash'],\r\n                        timestamp = Date.now(),\r\n                        sfFlashMessage = {};\r\n                    if (typeof response.action['flash'] === 'object'){\r\n                        sfFlashMessage = flash;\r\n                        sfFlashMessage.timestamp = timestamp;\r\n                    } else {\r\n                        sfFlashMessage = {\r\n                            message: flash,\r\n                            timestamp: timestamp\r\n                        }\r\n                    }\r\n                    sessionStorage.setItem('sfFlashMessage', JSON.stringify(sfFlashMessage));\r\n                }\r\n                if (keys.indexOf('redirect') !== -1){\r\n                    setTimeout(function () {\r\n                        sf.events.trigger('redirect', response.action['redirect'], options);\r\n                    }, +response.action.delay|0);\r\n                } else if (keys.indexOf('name') !== -1) {\r\n                    setTimeout(function () {\r\n                        sf.events.trigger(response.action.name, response.action.url);\r\n                    }, +response.action.delay || 0);\r\n                }\r\n                //if (keys.length === 1) {//\"action\":{\"redirect\":\"/account\"}\r\n                //    sf.events.trigger(keys[0], response.action[keys[0]], options);\r\n                //} else if (keys.length === 2 && response.action.delay) {//\"action\":{\"redirect\":\"/account\",\"delay\":3000}\r\n                //    setTimeout(function () {\r\n                //        var action = keys.filter(function (value) {\r\n                //            return value !== 'delay';\r\n                //        })[0];\r\n                //        sf.events.trigger(action, response.action[action], options);\r\n                //    }, +response.action.delay);\r\n                //} else if (keys.length > 1) {//\"action\":{\"name\":\"redirect\",\"url\":\"/account\",\"delay\":3000}\r\n                //    setTimeout(function () {\r\n                //        sf.events.trigger(response.action.name, response.action, options);\r\n                //    }, +response.action.delay || 0);\r\n                //} else {\r\n                //    console.error(\"Action from server. Object doesn't have keys. \", response.action);\r\n                //}\r\n            } else {\r\n                console.error(\"Action from server. Something wrong. \", response.action);\r\n            }\r\n        }\r\n    });\r\n    (function (sfFlashMessage) {\r\n        if (!sfFlashMessage) return;\r\n        var message  = JSON.parse(sfFlashMessage),\r\n            timestamp = Date.now(),\r\n            node,\r\n            nodeWrapper,\r\n            flashClass;\r\n        if (timestamp - message.timestamp > 10000) return;\r\n        if (message.type === 'debug' || message.type === 'success'){\r\n            flashClass = 'debug'\r\n        } else if (message.type === 'info' || !message.type || message.type === 'notice'){\r\n            flashClass = 'info'\r\n        } else {\r\n            flashClass = 'danger'\r\n        }\r\n        node = document.createElement('div');\r\n        nodeWrapper = document.createElement('div');\r\n        nodeWrapper.classList.add('flash-wrapper');\r\n        node.classList.add('flash', flashClass);\r\n        node.innerHTML = message.message;\r\n        document.body.appendChild(nodeWrapper);\r\n        nodeWrapper.appendChild(node);\r\n        setTimeout(function(){nodeWrapper.classList.add('show');}, 1);\r\n        setTimeout(function(){nodeWrapper.classList.remove('show')}, message.timeout||5000);\r\n\r\n        sessionStorage.removeItem('sfFlashMessage');\r\n    }(sessionStorage.getItem('sfFlashMessage')))\r\n};","module.exports = function(events){\r\n    events.on(\"redirect\", function (event) {\r\n        var url = Object.prototype.toString.call(event) === \"[object String]\" ? event : event.url;\r\n        //http://stackoverflow.com/questions/10687099/how-to-test-if-a-url-string-is-absolute-or-relative\r\n        self.location[/^(?:[a-z]+:)?\\/\\//i.test(url) ? 'href' : 'pathname'] = url;\r\n    });\r\n\r\n    events.on('reload', function () {\r\n        location.reload();\r\n    });\r\n\r\n    events.on('refresh', function () {\r\n        events.trigger('reload');\r\n    });\r\n\r\n    events.on('close', function () {\r\n        self.close();\r\n    });\r\n};","\"use strict\";\r\n/**\r\n * Helper to manipulate DOM Events. It's a simple wrapper around \"addEventListener\" but it's store all functions and allow us to remove it all.\r\n * It's very helpful for die() method of instances\r\n * @TODO add to many nodes\r\n * @TODO new method like addEventListener  DOMEvents.on(node(s),event,callback,useCapture);\r\n * @constructor\r\n */\r\nvar DOMEvents = function(){\r\n    /**\r\n     * Internal storage for events\r\n     * @property {Array.<Object>} DOMEvents - dom events array\r\n     * @property {Object} DOMEvents.DOMNode -   DOM node\r\n     * @property {String} DOMEvents.eventType -   Event type\r\n     * @property {Function} DOMEvents.eventFunction -   Function\r\n     * @property {Boolean} DOMEvents.useCapture=false -   useCapture\r\n     * @property {Object} ... -   another object\r\n     * @private\r\n     */\r\n    this._DOMEventsStorage = [];\r\n};\r\n/**\r\n * Add event(s) to node(s).\r\n * @TODO add to many nodes\r\n * @param {Array.<Object>|Object} eventArray - event array or event itself\r\n * @param {Object} eventArray.DOMNode -   DOM node\r\n * @param {String} eventArray.eventType -   Event type\r\n * @param {Function} eventArray.eventFunction -   Function\r\n * @param {Boolean} [eventArray.useCapture=false] -   useCapture\r\n * @example\r\n * var DOMEventsInstance = new DOMEvents();\r\n * var eventOne = {\r\n *      DOMNode: document.getElementById(\"example\"),\r\n *      eventType: \"click\",\r\n *      eventFunction: function (e) {\r\n *          console.log(\"Hi there. Native  DOM events is:\",e);\r\n *      }\r\n * }\r\n *  var eventTwo = {\r\n *      DOMNode: document.getElementById(\"example2\"),\r\n *      eventType: \"mousedown\",\r\n *      eventFunction: function (e) {\r\n *          console.log(\"Hi there. mousedown event. Native  DOM events is:\",e);\r\n *      }\r\n * }\r\n *  DOMEventsInstance.add([eventOne,eventTwo]);\r\n */\r\nDOMEvents.prototype.add = function(eventArray){\r\n    if (Object.prototype.toString.call([]) !== \"[object Array]\"){\r\n        eventArray = [eventArray];\r\n    }\r\n    eventArray.forEach(function(val){\r\n        val.useCapture=!!(val.useCapture);\r\n        val.DOMNode.addEventListener(val.eventType,val.eventFunction,val.useCapture);\r\n        this._DOMEventsStorage.push(val);\r\n    },this)\r\n};\r\n/**\r\n * Remove events\r\n * @param {Array.<Object>} eventArray - event array\r\n * @param {Object} eventArray.DOMNode -   DOM node\r\n * @param {String} eventArray.eventType -   Event type\r\n * @param {Function} eventArray.eventFunction -   Function\r\n * @param {Boolean} [eventArray.useCapture=false] -   useCapture\r\n */\r\nDOMEvents.prototype.remove = function(eventArray){\r\n//TODO IMPLEMENT\r\n    // TODO не уверен что этот метод необходим. если надо часто убирать какието обработчики, то лучше поставить обработчки на родителя\r\n    console.warn(\"TODO IMPLEMENT\");\r\n\r\n};\r\n/**\r\n * Remove all dom events registered with this instance (added by method add)\r\n * @example\r\n * //look at add method as first part of this code\r\n * DOMEventsInstance.removeAll();\r\n */\r\nDOMEvents.prototype.removeAll = function(){\r\n    this._DOMEventsStorage.forEach(function(val){\r\n        val.DOMNode.removeEventListener(val.eventType,val.eventFunction,val.useCapture);\r\n    });\r\n    this._DOMEventsStorage=[];\r\n};\r\n\r\nmodule.exports = DOMEvents;","\"use strict\";\r\n\r\n/**\r\n * This object try to be easy as FormData.\r\n * Please note this is not(!) a shim for Form data, because it's impossible (you should set headers for Ajax by hands)\r\n * It take object and can convert it string like FormData do. Then you can send this string by Ajax or do some other staff.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData\r\n * @param {Object} [data] object with data (supports nested objects)\r\n * @param {String} [boundary] boundary  for Form Data\r\n * @constructor\r\n * @example\r\n * var formData = new LikeFormData({testKey:\"testValue\"},\"testBoundary\");\r\n * formData.toString();\r\n * // Returns:\r\n * //\"--testBoundary\r\n * //Content-Disposition: form-data; name=testKey\r\n * //\r\n * // testValue\r\n * //--testBoundary--\r\n * //\"\r\n *\r\n * @example\r\n * var formData = new LikeFormData({testKey:\"testValue\"});\r\n * formData.toString();\r\n * // Returns:\r\n * //\"--SpiralFormData-4935309085994959\r\n * //Content-Disposition: form-data; name=testKey\r\n * //\r\n * // testValue\r\n * //--SpiralFormData-4935309085994959--\r\n * //\"\r\n *\r\n * @example\r\n * var formData = new LikeFormData({testKey:\"testValue\"});\r\n * formData.append(\"key2\",\"val2\");\r\n * formData.toString();\r\n * // Returns:\r\n * //--SpiralFormData-988681384595111\r\n * //Content-Disposition: form-data; name=testKey\r\n * //\r\n * //testValue\r\n * //--SpiralFormData-988681384595111\r\n * //Content-Disposition: form-data; name=key2\r\n * //\r\n * //val2\r\n * //--SpiralFormData-988681384595111--\r\n * //\"\r\n */\r\nvar LikeFormData = function (data, boundary) {\r\n    this.data = {};\r\n    if (data) {\r\n        if (Object.prototype.toString.call(data) !== \"[object Object]\") {//non object/ Alert developer\r\n            console.warn(\"LikeFormData can't accept non Object. Please reefer to documentation. Problem parameter is:\", data);\r\n        } else {\r\n            this.data = data;\r\n        }\r\n    }\r\n    this.boundary = (boundary) ? boundary : (\"SpiralFormData-\" + Math.random().toString().substr(2));\r\n\r\n\r\n    //if (!isOldIE) {\r\n    //    this.boundary = \"SpiralAjax-\" + Math.random().toString().substr(2);\r\n    //    //xhr.setRequestHeader(\"content-type\", \"multipart/form-data; charset=utf-8; boundary=\" + this.boundary);\r\n    //} else {\r\n    //    this.boundary = \"SpiralAjax-oldIE9876gsloiHGldowu\";\r\n    //}\r\n\r\n};\r\n/**\r\n * Append data to storage. Like standart FormData do.\r\n * @param {String} key\r\n * @param {String} val\r\n * @example\r\n * var formData = new FormData();\r\n * formData.append(\"key2\",\"val2\");\r\n */\r\nLikeFormData.prototype.append = function (key, val) {\r\n    //https://developer.mozilla.org/en-US/docs/Web/API/FormData\r\n    //TODO ***Appends a new value**** onto an existing key inside a FormData object, or adds the key if it does not already exist.\r\n    this.data[key] = val;\r\n};\r\n\r\n/**\r\n * convert to string\r\n * @example\r\n * var formData = new LikeFormData({testKey:\"testValue\"});\r\n * formData.toString();\r\n * // Returns:\r\n * //\"--SpiralFormData-4935309085994959\r\n * //Content-Disposition: form-data; name=testKey\r\n * //\r\n * // testValue\r\n * //--SpiralFormData-4935309085994959--\r\n * //\"\r\n */\r\nLikeFormData.prototype.toString = function () {\r\n    var retString = \"\";\r\n    var boundary = this.boundary;\r\n    var iterate = function (data, partOfKey) {\r\n        for (var key in data) {\r\n            if (data.hasOwnProperty(key) && (typeof data[key] !== \"undefined\" )) {\r\n                if (typeof data[key] === \"object\") {\r\n                    iterate(data[key], ((partOfKey.length === 0) ? key : (partOfKey + \"[\" + key + \"]\")));\r\n                } else {\r\n                    retString += \"--\" + boundary\r\n                        + \"\\r\\nContent-Disposition: form-data; name=\" + ((partOfKey.length === 0) ? key : (partOfKey + \"[\" + key + \"]\"))\r\n                        + \"\\r\\n\\r\\n\" + data[key] + \"\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n    };\r\n    if (typeof this.data !== \"object\") {\r\n        this.data = {\r\n            data: this.data\r\n        }\r\n    }\r\n    iterate(this.data, \"\");\r\n\r\n\r\n    retString += \"--\" + this.boundary + \"--\\r\\n\";\r\n    return retString;\r\n};\r\n\r\n/**\r\n * The delete() method of the FormData interface deletes a key/value pair from a FormData object.\r\n * @param key\r\n */\r\nLikeFormData.prototype.delete = function (key) {\r\n    return delete(this.data[key]);\r\n};\r\n\r\n\r\n/**\r\n *The get() method of the FormData interface returns the first value associated with a given key from within a FormData object.\r\n * @param key\r\n */\r\nLikeFormData.prototype.get = function (key) {\r\n    return this.data[key];\r\n};\r\n/**\r\n *The getAll() method of the FormData interface returns the first value associated with a given key from within a FormData object.\r\n */\r\nLikeFormData.prototype.getAll = function () {\r\n    return this.data;\r\n};\r\n\r\n/**\r\n * The has() method of the FormData interface returns a boolean stating whether a FormData object contains a certain key/value pair.\r\n * @param key\r\n */\r\nLikeFormData.prototype.has = function(key){\r\n    return this.data.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * The difference between set() and FormData.append is that if the specified header does already exist, set() will overwrite the existing value with the new one, whereas FormData.append will append the new value onto the end of the set of values.\r\n * @param key\r\n * @param val\r\n */\r\nLikeFormData.prototype.set = function(key, val){\r\n    this.data[key] = val;\r\n};\r\n\r\n/**\r\n * Get content header to set for Ajax. Not a part of standart FormData object. But for sending Like FormData over Ajax you should know header.\r\n * @return {string}\r\n * @example\r\n * var formData = new LikeFormData();\r\n * formData.getContentTypeHeader(); //return \"multipart/form-data; charset=utf-8; boundary=SpiralFormData-988681384595111\"\r\n * @example\r\n * var formData = new LikeFormData({key:\"val2\"},\"testBoundary\");\r\n * formData.getContentTypeHeader(); //return \"multipart/form-data; charset=utf-8; boundary=testBoundary\"\r\n */\r\nLikeFormData.prototype.getContentTypeHeader = function () {\r\n    return \"multipart/form-data; charset=utf-8; boundary=\" + this.boundary;\r\n\r\n};\r\n\r\n\r\nmodule.exports = LikeFormData;","/**\r\n This is a collection of useful DOM tools.\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Found first parent node with matched selector(s)\r\n     * @param {Object} elem - dom node\r\n     * @param {String|Array} selectors - selector or array of selectors\r\n     * @returns {Object| Boolean} - node or false\r\n     */\r\n\r\n    closest: function (elem, selectors) {\r\n        selectors = (typeof selectors === 'string') ? [selectors] : selectors;\r\n        var key,\r\n            l = selectors.length,\r\n            matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;\r\n        while (elem && elem.parentNode) {\r\n            for (key = 0; key < l; key++) {\r\n                if (matchesSelector.call(elem, selectors[key])) {\r\n                    return elem;\r\n                }\r\n            }\r\n            elem = elem.parentNode;\r\n        }\r\n        return false;\r\n    },\r\n    /**\r\n     * Found first parent node with matched className(s).\r\n     * TODO Why this? Because old IE....\r\n     * TODO It's not good, because it's a copy of closest @see closest. Refactor\r\n     * @param {Object} elem - dom node\r\n     * @param {String|Array} className - className or array of classNames\r\n     * @returns {Object| Boolean} - node or false\r\n     */\r\n\r\n    closestByClassName: function (elem, className) {\r\n        className = (typeof className === 'string') ? [className] : className;\r\n        var key,\r\n            l = className.length;\r\n        //,matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;\r\n        while (elem && elem.parentNode) {\r\n            for (key = 0; key < l; key++) {\r\n                var reg = new RegExp(\"(\\\\s|^)\" + className[key] + \"(\\\\s|$)\");\r\n                if (elem.className.match(reg)) {\r\n                    return elem;\r\n                }\r\n            }\r\n            elem = elem.parentNode;\r\n        }\r\n        return false;\r\n    }\r\n};","\"use strict\";\r\n\r\n/**\r\n * @module tools\r\n * @namespace\r\n */\r\nvar tools = {\r\n    resolveKeyPath : function(path, obj, safe) {\r\n        return path.split('.').reduce(function(prev, curr) {\r\n            return !safe ? prev[curr] : (prev ? prev[curr] : void 0)\r\n        }, obj||self)\r\n    }\r\n};\r\n\r\nmodule.exports = tools;","\"use strict\";\r\n//https://github.com/spiral/sf.js\r\n\r\n//Add console shim for old IE\r\nrequire(\"./shim/console\");\r\nrequire(\"./shim/Object.assign\");\r\nif (typeof Promise != 'function') {\r\n    var Promise = require('es6-promise').Promise;\r\n}\r\n\r\nvar _sf;\r\n\r\nif (typeof sf !== 'undefined' && Object.prototype.toString.call(sf) === \"[object Object]\") {\r\n    _sf = Object.assign(sf, require(\"./sf\"));\r\n} else {\r\n    _sf = require(\"./sf\");\r\n}\r\n\r\nif (!_sf.hasOwnProperty('options')) _sf.options = {instances:{}};\r\nif (!_sf.options.hasOwnProperty('instances')) _sf.options.instances = {};\r\n\r\n//todo delete this in future\r\nif (!window.hasOwnProperty(\"sf\")) {//bind only if  window.sf is empty to avoid conflicts with other libs\r\n    window.sf = _sf;\r\n}\r\n\r\n_sf.instancesController = new _sf.core.InstancesController(sf);\r\n_sf.domMutation = new _sf.core.DomMutations(_sf.instancesController);\r\n\r\n//Events system\r\n_sf.events = new _sf.core.Events();\r\nrequire(\"./core/events/baseEvents.js\")(_sf.events);\r\n\r\n//AJAX\r\n_sf.ajax = new _sf.core.Ajax(window.csrfToken ? {//TODO move to spiral bindings\r\n    headers: {\r\n        \"X-CSRF-Token\": window.csrfToken\r\n    }\r\n} : null);\r\nrequire(\"./core/ajax/baseActions.js\")(_sf);\r\n\r\n//API\r\n_sf.createModulePrototype = function() { return Object.create(_sf.modules.core.BaseDOMConstructor.prototype)};\r\n_sf.registerInstanceType = _sf.instancesController.registerInstanceType.bind(_sf.instancesController);\r\n_sf.addInstance = _sf.instancesController.addInstance.bind(_sf.instancesController);\r\n_sf.removeInstance = _sf.instancesController.removeInstance.bind(_sf.instancesController);\r\n_sf.getInstance = _sf.instancesController.getInstance.bind(_sf.instancesController);\r\n_sf.getInstances = _sf.instancesController.getInstances.bind(_sf.instancesController);\r\n\r\n_sf.closest = sf.helpers.domTools.closest;\r\n_sf.resolveKeyPath = sf.tools.resolveKeyPath;\r\n\r\nif (typeof exports === \"object\" && exports) {\r\n    module.exports = _sf;\r\n}","var core = {\r\n    Ajax: require(\"./core/Ajax\"),\r\n    BaseDOMConstructor: require(\"./core/BaseDOMConstructor\"),\r\n    DomMutations: require(\"./core/DomMutations\"),\r\n    Events: require(\"./core/Events\"),\r\n    InstancesController: require(\"./core/InstancesController\")\r\n};\r\n\r\nvar helpers = {\r\n    DOMEvents: require(\"./helpers/DOMEvents\"),\r\n    domTools: require(\"./helpers/domTools\"),\r\n    LikeFormData: require(\"./helpers/LikeFormData\"),\r\n    tools: require(\"./helpers/tools\")\r\n};\r\n\r\nvar sf = {\r\n    core: core,\r\n    helpers: helpers,\r\n    tools: helpers.tools,\r\n    modules: {//todo remove this when removed in dependencies\r\n        'WILL_BE_DEPRECATED': true,\r\n        core: core,\r\n        helpers: helpers\r\n    }\r\n};\r\n\r\nmodule.exports = sf;","/**\r\n * Object.assign polyfill\r\n * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n */\r\nif (typeof Object.assign != 'function') {\r\n    (function () {\r\n        Object.assign = function (target) {\r\n            'use strict';\r\n            if (target === undefined || target === null) {\r\n                throw new TypeError('Cannot convert undefined or null to object');\r\n            }\r\n\r\n            var output = Object(target);\r\n            for (var index = 1; index < arguments.length; index++) {\r\n                var source = arguments[index];\r\n                if (source !== undefined && source !== null) {\r\n                    for (var nextKey in source) {\r\n                        if (source.hasOwnProperty(nextKey)) {\r\n                            output[nextKey] = source[nextKey];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return output;\r\n        };\r\n    })();\r\n}","/**\r\n * Avoid `console` errors in browsers that lack a console.\r\n */\r\n(function () {\r\n    var method, noop = function () {\r\n        },\r\n        methods = [\r\n            'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',\r\n            'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',\r\n            'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',\r\n            'timeStamp', 'trace', 'warn'\r\n        ],\r\n        length = methods.length,\r\n        console = (window.console = window.console || {});\r\n\r\n    while (length--) {\r\n        method = methods[length];\r\n\r\n        // Only stub undefined methods.\r\n        if (!console[method]) {\r\n            console[method] = noop;\r\n        }\r\n    }\r\n}());\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJzcmMvY29yZS9BamF4LmpzIiwic3JjL2NvcmUvQmFzZURPTUNvbnN0cnVjdG9yLmpzIiwic3JjL2NvcmUvRG9tTXV0YXRpb25zLmpzIiwic3JjL2NvcmUvRXZlbnRzLmpzIiwic3JjL2NvcmUvSW5zdGFuY2VzQ29udHJvbGxlci5qcyIsInNyYy9jb3JlL2FqYXgvYmFzZUFjdGlvbnMuanMiLCJzcmMvY29yZS9ldmVudHMvYmFzZUV2ZW50cy5qcyIsInNyYy9oZWxwZXJzL0RPTUV2ZW50cy5qcyIsInNyYy9oZWxwZXJzL0xpa2VGb3JtRGF0YS5qcyIsInNyYy9oZWxwZXJzL2RvbVRvb2xzLmpzIiwic3JjL2hlbHBlcnMvdG9vbHMuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvc2YuanMiLCJzcmMvc2hpbS9PYmplY3QuYXNzaWduLmpzIiwic3JjL3NoaW0vY29uc29sZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDam9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4zLjFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJCA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJCkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3JlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgX2lucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShfaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJCA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkID09PSByZXNvbHZlKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcblByb21pc2UucmFjZSA9IHJhY2U7XG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5Qcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlO1xufVxuXG5wb2x5ZmlsbCgpO1xuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcblxucmV0dXJuIFByb21pc2U7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgdG9vbHMgPSByZXF1aXJlKFwiLi4vaGVscGVycy90b29sc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi9jb3JlL0V2ZW50c1wiKTtcclxudmFyIExpa2VGb3JtRGF0YSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL0xpa2VGb3JtRGF0YVwiKTtcclxuLyoqXHJcbiAqIFRoaXMgaXMgYW4gQWpheCB0cmFuc3BvcnQuXHJcbiAqIFN1cHBvcnRzICBYRG9tYWluUmVxdWVzdCBmb3Igb2xkIElFXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIEhlYWRlcnMgdG8gYWRkIHRvIHRoZSBpbnN0YW5jZVxyXG4gKiBAZmlyZXMgYmVmb3JlU2VuZCBldmVudCB0aGF0IHdpbGwgYmUgcGVyZm9ybWVkIGJlZm9yZSByZXF1ZXN0IGlzIHNlbmQuIEV2ZW50IGNhbGxlZCB3aXRoIG9uZSBwYXJhbWV0ZXIgXCJvcHRpb25zXCIsIHRoYXQgY29udGFpbnMgYWxsIHZhcmlhYmxlcyBmb3IgQWpheFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBBamF4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuY3VycmVudFJlcXVlc3RzID0gMDtcclxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50cyhbXCJiZWZvcmVTZW5kXCIsICdsb2FkJ10pO1xyXG5cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycykge1xyXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24odGhpcy5oZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgaGVhZGVycy4gWW91IGNhbiBvdmVyd3JpdGUgaXQuIExvb2sgYXQgdGhlIGV2ZW50IGJlZm9yZVNlbmRcclxuICogUGxlYXNlIG5vdGUgdGhhdCBvbiBYRG9tYWluUmVxdWVzdCAgd2UgY2FuJ3Qgc2VuZCBhbnkgaGVhZGVycy5cclxuICogQHR5cGUgT2JqZWN0XHJcbiAqL1xyXG5BamF4LnByb3RvdHlwZS5oZWFkZXJzID0ge1xyXG4gICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnXHJcbn07XHJcblxyXG4vKipcclxuICogU2VuZCBhamF4IHJlcXVlc3QgdG8gc2VydmVyXHJcbiAqIFdpbGwgcmV0dXJuIHByb21pc2Ugb3IgYXJyYXkgd2l0aCBwcm9taXNlIGFuZCBYTUxIdHRwUmVxdWVzdCA6IHt3aW5kb3cuUHJvbWlzZXxbd2luZG93LlByb21pc2UsWE1MSHR0cFJlcXVlc3RdfVxyXG4gKiBAc2luY2UgMC40LjBcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0IHdpdGggb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgdXJsIHRvIHNlbmQgZGF0YVxyXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLmRhdGFdIGRhdGEgdG8gc2VuZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kXVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gaGVhZGVycyB0byBhZGQgdG8gdGhlIHJlcXVlc3RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25Qcm9ncmVzc10gY2FsbGJhY2sgZnVuY3Rpb24gb24gcHJvZ3Jlc3MuIFR3byBjYWxsYmFjayBvcHRpb25zOiBjdXJyZW50IGJ5dGVzIHNlbnQsdG90YWxCeXRlc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5pc1JldHVyblhIUlRvbz09PWZhbHNlXSBzaG91bGQgbWV0aG9kIHJldHVybiBhcnJheSBpbnN0ZWFkIG9mIFByb21pc2UuIFNvbWUgdGltZXMgaXMgbmVlZGVkIHRvIGNvbnRyb2wgYWpheCAoYWJvcnQsIGV0YykuIElmIHRyZWUgdGhlbiAgW3dpbmRvdy5Qcm9taXNlLFhNTEh0dHBSZXF1ZXN0IF0gd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZXxBcnJheX1cclxuICovXHJcbkFqYXgucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIC8vVE9ETyB3aHkgd2UgY2hlY2sgaGVyZSBpZiBkYXRhID09PSBudWxsIHRoZW4gcmVhc3NpZ24gdG8gbnVsbCBhZ2Fpbj9cclxuICAgIGlmIChvcHRpb25zLmRhdGEgPT09IG51bGwgfHwgb3B0aW9ucy5kYXRhID09PSB2b2lkIDAgfHwgb3B0aW9ucy5kYXRhID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9wdGlvbnMubWV0aG9kKSB7XHJcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBcIlBPU1RcIlxyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyA/IE9iamVjdC5hc3NpZ24ob3B0aW9ucy5oZWFkZXJzLCB0aGlzLmhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycykgOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xyXG4gICAgdmFyIHhocjtcclxuICAgIHZhciBhamF4UHJvbWlzZSA9ICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7ICAgIC8vIFJldHVybiBhIG5ldyBwcm9taXNlLlxyXG4gICAgICAgIGlmICghb3B0aW9ucy51cmwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBzaG91bGQgcHJvdmlkZSB1cmxcIik7XHJcbiAgICAgICAgICAgIHJlamVjdChcIllvdSBzaG91bGQgcHJvdmlkZSB1cmxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQuY3VycmVudFJlcXVlc3RzKys7XHJcblxyXG4gICAgICAgIHZhciBvbGRJRSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBuZXcgWE1MSHR0cFJlcXVlc3QoKS5yZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZCkgJiYgKHVybC5pbmRleE9mKFwiaHR0cFwiKSA9PT0gMCkpIHsvL29sZCBJRSBDT1JTXHJcbiAgICAgICAgICAgIC8vVE9ETyBtYXliZSB3ZSBzaG91bGQgdXNlIFhEb21haW5SZXF1ZXN0IG9ubHkgZm9yIGNyb3NzIGRvbWFpbiByZXF1ZXN0cz8gQnV0ICBTcGlyYWwgZm9yIG5vdyB3b3JrcyBncmVhdCB3aXRoIFhEb21haW5SZXF1ZXN0IChiYXNlZCBvbiBJRUpTT04pXHJcbiAgICAgICAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAvL2h0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcclxuICAgICAgICAgICAgb2xkSUUgPSB0cnVlO1xyXG4gICAgICAgICAgICAvL2h0dHA6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9pZS9lbi1VUy8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmUvaWU5LXJ0bS14ZG9tYWlucmVxdWVzdC1pc3N1ZWQtcmVxdWVzdHMtbWF5LWFib3J0LWlmLWFsbC1ldmVudC1oYW5kbGVycy1ub3Qtc3BlY2lmaWVkP2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcclxuICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPIGFkanVzdCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUHJvZ3Jlc3MgJiYgb3B0aW9ucy5vblByb2dyZXNzKGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uUHJvZ3Jlc3MoZXZlbnQubG9hZGVkLCBldmVudC50b3RhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCk7XHJcblxyXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7Ly9PbiBsb2FkZWRcclxuICAgICAgICAgICAgdGhhdC5jdXJyZW50UmVxdWVzdHMtLTtcclxuICAgICAgICAgICAgdmFyIGFucyA9IHRoYXQuX3BhcnNlSlNPTih4aHIpO1xyXG4gICAgICAgICAgICBpZiAoYW5zLnN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFucy5zdGF0dXMgPiAxOTkgJiYgYW5zLnN0YXR1cyA8IDMwMCkgey8vMjAwLTI5OVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYW5zKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5zLnN0YXR1cyA+IDM5OSAmJiBhbnMuc3RhdHVzIDwgNjAwKSB7Ly80MDAtNTk5XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGFucyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ1bmtub3duIHN0YXR1cyAlZC4gUmVqZWN0aW5nXCIsIGFucy5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChhbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRJRSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhbnMpOy8vT0xEIElFICsgZG93bmxvYWRpbmcgZmlsZSBpcyBwcm9kdWNpbmcgIG5vIHN0YXR1cy5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChhbnMpOy8vcmVqZWN0IHdpdGggdGhlIHN0YXR1cyB0ZXh0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZSA9IGFucztcclxuICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcihcImxvYWRcIiwgb3B0aW9ucyk7Ly9mb3IgZXhhbXBsZSAtIHVzZWQgdG8gaGFuZGxlIGFjdGlvbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgey8vIEhhbmRsZSBuZXR3b3JrIGVycm9yc1xyXG4gICAgICAgICAgICB0aGF0LmN1cnJlbnRSZXF1ZXN0cy0tO1xyXG4gICAgICAgICAgICByZWplY3QoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpLCB4aHIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoXCJiZWZvcmVTZW5kXCIsIG9wdGlvbnMpOy8veW91IGNhbiBtb2RpZnkgXCJvcHRpb25zXCIgb2JqZWN0IGluc2lkZSBldmVudCAobGlrZSBhZGRpbmcgeW91IGhlYWRlcnMsZGF0YSxldGMpXHJcblxyXG4gICAgICAgIHZhciBkYXRhVG9TZW5kO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHsvL2lmIGRhdGEgdG8gc2VuZCBpcyBub3QgZW1wdHlcclxuICAgICAgICAgICAgaWYgKCFvbGRJRSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS50b1N0cmluZygpLmluZGV4T2YoXCJGb3JtRGF0YVwiKSAhPT0gLTEpIHsvL2lmIGZvcm0gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQgPSBuZXcgTGlrZUZvcm1EYXRhKG9wdGlvbnMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gZGF0YVRvU2VuZC5nZXRDb250ZW50VHlwZUhlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5fc2V0SGVhZGVycyh4aHIsIG9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVRvU2VuZCA9IFwiSUVKU09OXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHsvL2Vsc2Ugc2VuZCBlbXB0eSBkYXRhXHJcbiAgICAgICAgICAgIGRhdGFUb1NlbmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4vLyAgICAgICAgaWYgKCFvbGRJRSkge1xyXG4vLyAgICAgICAgICAgIC8veGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcclxuLy8gICAgICAgICAgICBkYXRhVG9TZW5kID0gbmV3IHNwaXJhbC5MaWtlRm9ybURhdGEoZGF0YSwgeGhyLCBvbGRJRSk7XHJcbi8vICAgICAgICB9IGVsc2Uge1xyXG4vLyAgICAgICAgICAgIGlmIChkYXRhICE9PW51bGwgJiYgZGF0YSAhPT0gdm9pZCAwICYmIGRhdGEgIT09ICd1bmRlZmluZWQnKXtcclxuLy8gICAgICAgICAgICAgICAgZGF0YVRvU2VuZCA9IFwiSUVKU09OXCIrSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbi8vICAgICAgICAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQgPWRhdGE7XHJcbi8vICAgICAgICAgICAgfVxyXG4vL1xyXG4vLyAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdHJ5IHsvL3dvcmtpbmcgYXJvdW5kIEZGIGJ1Z1xyXG4gICAgICAgICAgICB4aHIuc2VuZChkYXRhVG9TZW5kKTsvLyBNYWtlIHRoZSByZXF1ZXN0XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUuZXJyb3IoXCJlcnJvciBzZW5kaW5nIHRyeWluZyBhbm90aGVyIG1ldGhvZFwiKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoZGF0YVRvU2VuZC50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4aHI7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5pc1JldHVyblhIUlRvbyl7Ly9yZXR1cm4geGhyIHRvb1xyXG4gICAgICAgIHJldHVybiBbYWpheFByb21pc2UseGhyXVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFqYXhQcm9taXNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEl0ZXJhdGUgb3ZlciBoZWFkZXJzIG9iamVjdCBhbmQgY2FsbCB4aHIuc2V0UmVxdWVzdEhlYWRlclxyXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcclxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgb2JqZWN0IHdpdGggaGVhZGVycyB0byBzZXRcclxuICovXHJcbkFqYXgucHJvdG90eXBlLl9zZXRIZWFkZXJzID0gZnVuY3Rpb24gKHhociwgaGVhZGVycykge1xyXG4gICAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcclxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG4vKipcclxuICogVHJ5IHRvIHBhcnNlIGFuZCBub3JtYWxpemUgYW5zd2VyXHJcbiAqIEBwYXJhbSB4aHJcclxuICogQHJldHVybnMgeyp9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5BamF4LnByb3RvdHlwZS5fcGFyc2VKU09OID0gZnVuY3Rpb24gKHhocikge1xyXG4gICAgaWYgKCF4aHIucmVzcG9uc2UpIHtcclxuICAgICAgICB4aHIucmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgfVxyXG4gICAgdmFyIHJldCA9IHt9O1xyXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gZmFsc2U7XHJcbiAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKSB7XHJcbiAgICAgICAgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb250ZW50VHlwZSB8fCBjb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpID09PSAnYXBwbGljYXRpb24vanNvbicgfHwgY29udGVudFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQvanNvbicgfHwgY29udGVudFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2lub2RlL3N5bWxpbmsnKSB7Ly9hcHBsaWNhdGlvbi9qc29uIG9yIGlub2RlL3N5bWxpbmsgIChBbWF6b25TMyBidWc/IClcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXQgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm90IGEgSlNPTiFcIiwgeGhyLnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgcmV0ID0ge2RhdGE6IHhoci5yZXNwb25zZX07XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXQgPSB7ZGF0YTogeGhyLnJlc3BvbnNlfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJldC5zdGF0dXMpIHtcclxuICAgICAgICByZXQuc3RhdHVzID0geGhyLnN0YXR1cztcclxuICAgIH1cclxuICAgIC8vU29tZSBzZXJ2ZXJzIGNhbiBhbnN3ZXIgc3RhdHVzIGluIEpTT04gYXMgXCJIVFRQLzEuMSAyMDAgT0tcIiAgYnV0IHdlIG5lZWQgYSBzdGF0dXMgbnVtYmVyXHJcbiAgICBpZiAodHlwZW9mIHJldC5zdGF0dXMgPT09ICdzdHJpbmcnICYmIHJldC5zdGF0dXMuaW5kZXhPZihcIkhUVFAvXCIpID09PSAwICYmIHJldC5zdGF0dXMubWF0Y2goIC8gKFxcZFxcZFxcZCkvICkpIHtcclxuICAgICAgICByZXQuc3RhdHVzID0gcGFyc2VJbnQocmV0LnN0YXR1cy5tYXRjaCggLyAoXFxkXFxkXFxkKS8gKVsxXSk7Ly9UT0RPIGNoZWNrIHRoaXMgY29kZVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAoIXJldC5zdGF0dXNUZXh0KSB7XHJcbiAgICAgICAgcmV0LnN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcclxuICAgIH1cclxuICAgIGlmICh4aHIuc3RhdHVzICYmIHhoci5zdGF0dXMgIT0gcmV0LnN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlN0YXR1cyBmcm9tIHJlcXVlc3QgJWQsIGJ1dCByZXNwb25zZSBjb250YWlucyBzdGF0dXMgJWRcIiwgeGhyLnN0YXR1cywgcmV0LnN0YXR1cylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG5cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXg7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgYSBiYXNlIGNvbnN0cnVjdG9yIChjbGFzcykgZm9yIGFueSBET00gYmFzZWQgaW5zdGFuY2UuXHJcbiAqIFRoaXMgY29uc3RydWN0b3IganVzdCBncmFiIGFsbCBub2RlIGF0dHJpYnV0ZXMgYW5kIGdlbmVyYXRlcyBvcHRpb25zLiBBbGwgcHJvY2Vzc2VkIG9wdGlvbnMgc3RvcmVkIGF0IHRoaXMub3B0aW9uc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBXZSBoYXZlIGh0bWwgbGlrZSB0aGlzOlxyXG4gKiA8ZGl2IGRhdGEtdGVzdD1cInRlc3RWYWx1ZVwiIGRhdGEtdmFsdWU9XCJ2YWx1ZTEyM1wiPi4uLi4uPC9kaXY+XHJcbiAqIHRoaXMub3B0aW9ucyB3aWxsIGJlOlxyXG4gKiB7XHJcbiAqICB0ZXN0OlwidGVzdFZhbHVlXCIsXHJcbiAqICB2YWx1ZTpcInZhbHVlXCJcclxuICogfVxyXG4gKiBOb3RlOiBkYXRhLXRlc3QgYW5kIGRhdGEtdmFsdWUgc2hvdWxkIGJlIGRlc2NyaWJlZCBpbiBhdHRyaWJ1dGVzVG9HcmFiXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEJhc2VET01Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuLyoqXHJcbiAqIEluaXQgbWV0aG9kLiBDYWxsIGFmdGVyIGNvbnN0cnVjdCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2ZcclxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgIERvbU5vZGUgb2YgZm9ybVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGFsbCBvcHRpb25zIHRvIG92ZXJyaWRlIGRlZmF1bHRcclxuICovXHJcbkJhc2VET01Db25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChzZiwgbm9kZSwgb3B0aW9ucykge1xyXG4gICAgLy9UT0RPIGRhdGEtc3BpcmFsLUpTT05cclxuICAgIHRoaXMuc2YgPSBzZjtcclxuICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAvL2lmIChzZi5vcHRpb25zICYmIHNmLm9wdGlvbnMuaW5zdGFuY2VzICYmIHNmLm9wdGlvbnMuaW5zdGFuY2VzW3RoaXMubmFtZV0pIHtcclxuICAgIC8vICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMgfHwge30sIHNmLm9wdGlvbnMuaW5zdGFuY2VzW3RoaXMubmFtZV0pO1xyXG4gICAgLy99XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMuZ3JhYk9wdGlvbnMobm9kZSksIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBvcHRpb25zIHRvIGdlbmVyYXRlLlxyXG4gKiBZb3Ugc2hvdWxkIHByb3ZpZGUgcHJvY2Vzc29yIG9yIHZhbHVlLlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydHlLZXkgLSBvYmplY3Qgb2YgcHJvcGVydHlcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3BlcnR5S2V5LnZhbHVlIC0gZGVmYXVsdCB2YWx1ZSB0byByZXR1cm5cclxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcm9wZXJ0eUtleS5kb21BdHRyXSAtIGRvbSBhdHRyaWJ1dGUgdG8gZ3JhYiBkYXRhXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtwcm9wZXJ0eUtleS5wcm9jZXNzb3JdIC0gIHByb2Nlc3NvciB0byBwcm9jZXNzIGRhdGEgYmVmb3JlIHJldHVyblxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gIC4uLiAtIEFub3RoZXIgb2JqZWN0IG9mIG9uZSBwcm9wZXJ0eVxyXG4gKiBAdHlwZSB7e319XHJcbiAqICBAZXhhbXBsZVxyXG4gKiBcInNvbWVBdHRyaWJ1dGVcIjogey8vIGtleVxyXG4gKiAgICAgIHZhbHVlOiB0cnVlLCAvL2RlZmF1bHQgVmFsdWVcclxuICogICAgICBkb21BdHRyOiBcImRhdGEtc29tZS1hdHRyaWJ1dGVcIiwgLy8gYXR0cmlidXRlIGZyb20gbm9kZSB0byBncmFiXHJcbiAqICAgICAgcHJvY2Vzc29yOiBmdW5jdGlvbiAobm9kZSx2YWwsc2VsZikgeyAvL3Byb2Nlc3NvciB0byBwcm9jZXNzIHZhbHVlcyBiZWZvcmUgcmV0dXJuXHJcbiAqICAgICAgICAgIC8vc29tZSBjYWxjdWxhdGlvbnNcclxuICogICAgICByZXR1cm4gc29tZVZhbHVlO1xyXG4gKiAgICAgIH1cclxuICogIH0sXHJcbiAqICBcImFub3RoZXJBdHRyaWJ1dGVcIjp7Li4ufSxcclxuICogIFwiLi4uXCJcclxuICpcclxuICogIEBleGFtcGxlXHJcbiAqICAvL3JldHVybiBub2RlIGFzIHZhbHVlXHJcbiAqICBcImNvbnRleHRcIjoge1xyXG4gKiAgICAgIFwicHJvY2Vzc29yXCI6IGZ1bmN0aW9uIChub2RlLHZhbCxrZXkpIHsgLy9wcm9jZXNzb3JcclxuICogICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAqICAgICAgfVxyXG4gKiAgfSxcclxuICogIFwiQW5vdGhlci1rZXlcIjp7Li4ufSxcclxuICogIFwiLi4uXCJcclxuICogQGV4YW1wbGVcclxuICogLy9HcmFiIGF0dHJpYnV0ZSBcImRhdGEtYXR0cmlidXRlXCIgYXMgXCJNeUF0dHJpYnV0ZVwiIGlmIGF0dHJpYnV0ZSBub3QgcHJvdmlkZWQgcmV0dXJuIFwiRGVmYXVsdFZhbHVlXCJcclxuICogLy8gRG9tIG5vZGUgPGRpdiBkYXRhLWF0dHJpYnV0ZT1cInNvbWVWYWx1ZVwiPjwvZGl2PlxyXG4gKiBcIk15QXR0cmlidXRlXCI6IHtcclxuICogICAgICB2YWx1ZTogXCJEZWZhdWx0VmFsdWVcIixcclxuICogICAgICBkb21BdHRyOiBcImRhdGEtYXR0cmlidXRlXCJcclxuICogIH1cclxuICogIC8vYWZ0ZXIgcHJvY2Vzc2luZyB3ZSBzaG91bGQgaGF2ZVxyXG4gKiAge1wiTXlBdHRyaWJ1dGVcIjpcInNvbWVWYWx1ZVwifVxyXG4gKlxyXG4gKiAgQGV4YW1wbGVcclxuICogLy9HcmFiIGF0dHJpYnV0ZSBcImRhdGEtYXR0cmlidXRlXCIgYXMgXCJNeUF0dHJpYnV0ZVwiIGFuZCByZXR1cm4gc29tZSB2YWx1ZSBpbnN0ZWFkXHJcbiAqIC8vRG9tIG5vZGUgIDxkaXYgZGF0YS1hdHRyaWJ1dGU9XCJzb21lVmFsdWVcIj48L2Rpdj5cclxuICogXCJNeUF0dHJpYnV0ZVwiOiB7XHJcbiAqICAgICAgZG9tQXR0cjogXCJkYXRhLWF0dHJpYnV0ZVwiLFxyXG4gKiAgICAgIHByb2Nlc3NvcjogZnVuY3Rpb24gKG5vZGUsdmFsLHNlbGYpIHtcclxuICogICAgICAgICAgcmV0dXJuIHZhbCtcIlNvbWVDYWxjdWxhdGlvblwiO1xyXG4gKiAgICAgIH1cclxuICogIH1cclxuICogIC8vYWZ0ZXIgcHJvY2Vzc2luZyB3ZSBzaG91bGQgaGF2ZVxyXG4gKiAge1wiTXlBdHRyaWJ1dGVcIjpcInNvbWVWYWx1ZVNvbWVDYWxjdWxhdGlvblwifVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL3JldHVybiBmdW5jdGlvbiBhcyB2YWx1ZVxyXG4gKiBwcm9jZXNzQW5zd2VyOiB7XHJcbiAqICAgICAgXCJ2YWx1ZVwiOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gKiAgICAgICAgIHJldHVybiBcInNvbWVWYWxcIjtcclxuICogICAgICB9XHJcbiAqICAvL2FmdGVyIHByb2Nlc3Npbmcgd2Ugc2hvdWxkIGhhdmVcclxuICogIHtcInByb2Nlc3NBbnN3ZXJcIjpmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gKiAgICAgICAgIHJldHVybiBcInNvbWVWYWxcIjtcclxuICogICAgICB9XHJcbiAqICAgfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL3JldHVybiBpbml0IHRpbWUgYXMgdmFsdWVcclxuICogaW5pdFRpbWU6IHtcclxuICogICAgICBcInByb2Nlc3NvclwiOiBmdW5jdGlvbiAobm9kZSx2YWwsc2VsZikge1xyXG4gKiAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWU7XHJcbiAqICAgICAgfVxyXG4gKiAgLy9hZnRlciBwcm9jZXNzaW5nIHdlIHNob3VsZCBoYXZlXHJcbiAqICB7XCJpbml0VGltZVwiOjE0Mjk4MDg5Nzc0MDR9XHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vcmV0dXJuIG90aGVyIHZhbHVlIGluc3RlYWQgb2YgcmVhbCBvbmVcclxuICogcHJvY2Vzc0Fuc3dlcjoge1xyXG4gKiAgICAgIFwicHJvY2Vzc29yXCI6IGZ1bmN0aW9uIChub2RlLHZhbCxzZWxmKSB7XHJcbiAqICAgICAgICAgcmV0dXJuIFwic29tZVZhbFwiO1xyXG4gKiAgICAgIH1cclxuICogIC8vYWZ0ZXIgcHJvY2Vzc2luZyB3ZSBzaG91bGQgaGF2ZVxyXG4gKiAge1wicHJvY2Vzc0Fuc3dlclwiOlwic29tZVZhbFwifVxyXG4gKi9cclxuQmFzZURPTUNvbnN0cnVjdG9yLnByb3RvdHlwZS5vcHRpb25zVG9HcmFiID0ge307XHJcblxyXG4vKipcclxuICogR3JhYiBhbGwgb3B0aW9ucyB0aGF0IGRlc2NyaWJlZCBpbiBvcHRpb25zVG9HcmFiXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGRvbU5vZGVcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuQmFzZURPTUNvbnN0cnVjdG9yLnByb3RvdHlwZS5ncmFiT3B0aW9ucyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgdmFyIGN1cnJlbnRPcHRpb25WYWx1ZTtcclxuICAgIHZhciBjdXJyZW50T3B0aW9uO1xyXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIHRoaXMub3B0aW9uc1RvR3JhYikge1xyXG4gICAgICAgIGN1cnJlbnRPcHRpb25WYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1RvR3JhYi5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7Ly9pZiB0aGlzIGlzIG93biBvcHRpb25cclxuICAgICAgICAgICAgY3VycmVudE9wdGlvbiA9IHRoaXMub3B0aW9uc1RvR3JhYltvcHRpb25dO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE9wdGlvbi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7Ly93ZSBoYXZlIGRlZmF1bHQgb3B0aW9uLiBMZXQncyBncmFiIGl0IGZvciBmaXJzdFxyXG4gICAgICAgICAgICAgICAgY3VycmVudE9wdGlvblZhbHVlID0gY3VycmVudE9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Yub3B0aW9ucy5pbnN0YW5jZXNbdGhpcy5uYW1lXSAmJiB0aGlzLnNmLm9wdGlvbnMuaW5zdGFuY2VzW3RoaXMubmFtZV0uaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE9wdGlvblZhbHVlID0gdGhpcy5zZi5vcHRpb25zLmluc3RhbmNlc1t0aGlzLm5hbWVdW29wdGlvbl1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRPcHRpb24uaGFzT3duUHJvcGVydHkoXCJkb21BdHRyXCIpICYmIG5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShjdXJyZW50T3B0aW9uLmRvbUF0dHIpKSB7Ly93ZSBjYW4gZ3JhYiB0aGUgYXR0cmlidXRlIG9mIG5vZGVcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRPcHRpb25WYWx1ZSA9IG5vZGUuYXR0cmlidXRlc1tjdXJyZW50T3B0aW9uLmRvbUF0dHJdLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3VycmVudE9wdGlvbi5oYXNPd25Qcm9wZXJ0eShcInByb2Nlc3NvclwiKSkgey8vd2UgaGF2ZSBwcm9jZXNzb3IuIExldCdzIGV4ZWN1dGUgaXRcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRPcHRpb25WYWx1ZSA9IGN1cnJlbnRPcHRpb24ucHJvY2Vzc29yLmNhbGwodGhpcywgbm9kZSwgY3VycmVudE9wdGlvblZhbHVlLCBjdXJyZW50T3B0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRPcHRpb25WYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gY3VycmVudE9wdGlvblZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhZGRvbiBmb3IgaW5zdGFuY2VcclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZG9uVHlwZSB0eXBlIG9mIGFkZG9uIChtZXNzYWdlLGZpbGwsZXRjKVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkb25OYW1lIG5hbWUgb2YgYWRkb25cclxuICovXHJcbi8vZGVwcmljYXRlZFxyXG4vL0Jhc2VET01Db25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0QWRkb24gPSBmdW5jdGlvbiAoYWRkb25UeXBlLCBhZGRvbk5hbWUpIHtcclxuLy8gICAgcmV0dXJuIHRoaXMuc3BpcmFsLmluc3RhbmNlc0NvbnRyb2xsZXIuZ2V0SW5zdGFuY2VBZGRvbih0aGlzLm5hbWUsIGFkZG9uVHlwZSwgYWRkb25OYW1lKTtcclxuLy99O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRE9NQ29uc3RydWN0b3I7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogRG9tIG11dGF0aW9uLiBMaXN0ZW5pbmcgdG8gdGhlIERPTSBhbmQgYWRkIG9yIHJlbW92ZSBpbnN0YW5jZXMgYmFzZWQgb24gY2xhc3Nlcy5cclxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlc0NvbnRyb2xsZXIgIHNwaXJhbCBpbnN0YW5jZXNDb250cm9sbGVyLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnN0YW5jZXNDb250cm9sbGVyLmdldENsYXNzZXMgIGdldCBhbGwgcmVnaXN0ZXJlZCBtb2R1bGVzIGNsYXNzZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGluc3RhbmNlc0NvbnRyb2xsZXIuYWRkSW5zdGFuY2UgIGFkZCBpbnN0YW5jZSBtZXRob2QuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGluc3RhbmNlc0NvbnRyb2xsZXIucmVtb3ZlSW5zdGFuY2UgIHJlbW92ZSBpbnN0YW5jZSBtZXRob2RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRG9tTXV0YXRpb25zID0gZnVuY3Rpb24gKGluc3RhbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGlmICghaW5zdGFuY2VzQ29udHJvbGxlcil7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBzaG91bGQgcHJvdmlkZSBpbnN0YW5jZXNDb250cm9sbGVyICBmb3IgRE9NIE11dGF0aW9uLiBCZWNhdXNlIERPTSBNdXRhdGlvbiAgc2hvdWxkIGtub3duIGFsbCBjbGFzc2VzIGFuZFwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3Ipe1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQbGVhc2UgY2FsbCBEb21NdXRhdGlvbnMgd2l0aCBuZXcgIC0gJ25ldyBEb21NdXRhdGlvbnMoKScgXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuaW5zdGFuY2VzQ29udHJvbGxlciA9IGluc3RhbmNlc0NvbnRyb2xsZXI7XHJcbiAgICB2YXIgY29uZmlnID0gey8vY29uZmlnIGZvciBNdXRhdGlvbk9ic2VydmVyXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJjbGFzc1wiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkgey8vY2FsbCBmdW5jdGlvbiB3aGVuIGRvbSBtdXRhdGVkLlxyXG4gICAgICAgIHRoYXQub25Eb21NdXRhdGUuYXBwbHkodGhhdCwgYXJndW1lbnRzKVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIGNvbmZpZyk7Ly9zdGFydCBvYnNlcnZlclxyXG5cclxufTtcclxuLyoqXHJcbiAqIFdoZW4gZG9tIG11dGF0ZWQgdGhpcyBmdW5jdGlvbiBpZCBleGVjdXRlZC5cclxuICogQHBhcmFtIHtBcnJheX0gbXV0YXRpb25zIGFycmF5IG9mIG11dGF0aW9uc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkRvbU11dGF0aW9ucy5wcm90b3R5cGUub25Eb21NdXRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XHJcbiAgICB2YXIgY2xhc3NBcnJheSA9IHRoaXMuaW5zdGFuY2VzQ29udHJvbGxlci5nZXRDbGFzc2VzKCk7Ly9nZXQgYWxsIHJlZ2lzdGVyZWQgY2xhc3Nlc1xyXG4gICAgdmFyIGNsYXNzU2VsZWN0b3IgPSBcIi5cIiArIGNsYXNzQXJyYXkuam9pbihcIiwuXCIpOy8vY29udmVydCBmb3IgcXVlcnlTZWxlY3RvckFsbCgpXHJcbiAgICBpZiAoY2xhc3NTZWxlY3Rvci5sZW5ndGggPT09IDEpIHsvL2lmIG5vdCByZWdpc3RlcmVkIGFueSBpbnN0YW5jZVR5cGVzXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7Ly9sb29wIG92ZXIgbXV0YXRpb24gYXJyYXlcclxuICAgICAgICBzd2l0Y2ggKG11dGF0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZXNcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uQXR0cmlidXRlcyhtdXRhdGlvbiwgY2xhc3NBcnJheSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJjaGFyYWN0ZXJEYXRhXCI6XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRMaXN0XCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbkNoaWxkTGlzdChtdXRhdGlvbi5hZGRlZE5vZGVzLCBcImFkZEluc3RhbmNlXCIsIGNsYXNzU2VsZWN0b3IsIGNsYXNzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb25DaGlsZExpc3QobXV0YXRpb24ucmVtb3ZlZE5vZGVzLCBcInJlbW92ZUluc3RhbmNlXCIsIGNsYXNzU2VsZWN0b3IsIGNsYXNzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNvbWV0aGluZyB3cm9uZy4gQ29udGFjdCB0ZWNoIHN1cHBvcnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG5cclxuRG9tTXV0YXRpb25zLnByb3RvdHlwZS5wcm9jZXNzTXV0YXRpb25BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG11dGF0aW9uLCBjbGFzc0FycmF5KSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgY3VycmVudENsYXNzZXMgPSBtdXRhdGlvbi50YXJnZXQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSxcclxuICAgICAgICBvbGRDbGFzc2VzID0gKG11dGF0aW9uLm9sZFZhbHVlKT9tdXRhdGlvbi5vbGRWYWx1ZS5zcGxpdChcIiBcIik6W10sXHJcbiAgICAgICAgYWRkZWRDbGFzc2VzID0gY3VycmVudENsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChvbGRDbGFzc2VzLmluZGV4T2YodmFsKSA9PT0gLTEpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHJlbW92ZWRDbGFzc2VzID0gb2xkQ2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGN1cnJlbnRDbGFzc2VzLmluZGV4T2YodmFsKSA9PT0gLTEpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGFkZGVkUmVnaXN0ZXJlZENsYXNzZXMgPSBhZGRlZENsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChjbGFzc0FycmF5LmluZGV4T2YodmFsKSAhPT0gLTEpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHJlbW92ZWRSZWdpc3RlcmVkQ2xhc3NlcyA9IHJlbW92ZWRDbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY2xhc3NBcnJheS5pbmRleE9mKHZhbCkgIT09IC0xKTtcclxuICAgICAgICB9KTtcclxuICAgIHJlbW92ZWRSZWdpc3RlcmVkQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICB0aGF0Lmluc3RhbmNlc0NvbnRyb2xsZXIucmVtb3ZlSW5zdGFuY2UodGhhdC5pbnN0YW5jZXNDb250cm9sbGVyLmdldEluc3RhbmNlTmFtZUJ5Q3NzQ2xhc3ModmFsKSwgbXV0YXRpb24udGFyZ2V0KTtcclxuICAgIH0pO1xyXG4gICAgYWRkZWRSZWdpc3RlcmVkQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICB0aGF0Lmluc3RhbmNlc0NvbnRyb2xsZXIuYWRkSW5zdGFuY2UodGhhdC5pbnN0YW5jZXNDb250cm9sbGVyLmdldEluc3RhbmNlTmFtZUJ5Q3NzQ2xhc3ModmFsKSwgbXV0YXRpb24udGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIFByb2Nlc3MgbXV0YXRpb24gb24gQ2hpbGRMaXN0XHJcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzTGlzdCBhcnJheSB3aXRoIG5vZGVzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gYWN0aW9uIHRvIGNhbGwgKGFkZCBvciByZW1vdmUgbm9kZXMpXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc1NlbGVjdG9yIC0gc3RyaW5nIHNlbGVjdG9yIGZvciBxdWVyeVNlbGVjdG9yQWxsXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGNsYXNzQXJyYXkgLSBhcnJheSBvZiBhbGwgcmVnaXN0ZXJlZCBjbGFzc2VzXHJcbiAqL1xyXG5Eb21NdXRhdGlvbnMucHJvdG90eXBlLnByb2Nlc3NNdXRhdGlvbkNoaWxkTGlzdCA9IGZ1bmN0aW9uIChub2Rlc0xpc3QsIGFjdGlvbiwgY2xhc3NTZWxlY3RvciwgY2xhc3NBcnJheSkge1xyXG4gICAgdmFyIHRoYXQgPXRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIGZvciBjaGVja2luZyBub2RlIGNsYXNzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBkb20gbm9kZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSkge1xyXG4gICAgICAgIGNsYXNzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7Ly9sb29wIG92ZXIgcmVnaXN0ZXJlZCBjbGFzc2VzXHJcbiAgICAgICAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7Ly9pZiBjbGFzcyBtYXRjaCB0cnkgdG8gYWRkIG9yIHJlbW92ZSBpbnN0YW5jZSBmb3IgdGhpcyBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGF0Lmluc3RhbmNlc0NvbnRyb2xsZXJbYWN0aW9uXSh0aGF0Lmluc3RhbmNlc0NvbnRyb2xsZXIuZ2V0SW5zdGFuY2VOYW1lQnlDc3NDbGFzcyhjbGFzc05hbWUpLCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIFtdLmZvckVhY2guY2FsbChub2Rlc0xpc3QsIGZ1bmN0aW9uICh2YWwpIHsvL2xvb3Agb3ZlciBtdXRhdGlvbiBub2Rlc1xyXG4gICAgICAgIGlmICh2YWwubm9kZVR5cGUgIT09IDEgfHwgdmFsLm5vZGVOYW1lID09PSBcIlNDUklQVFwiIHx8IHZhbC5ub2RlTmFtZSA9PT0gXCJMSU5LXCIpIHsvL2RvIG5vdCBwcm9jZXNzIG90aGVyIG5vZGVzIHRoZW4gRUxFTUVOVF9OT0RFIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlLm5vZGVUeXBlIGFsc28gaWdub3JlIFNDUklQVCBhbmQgTElOSyB0YWdcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja05vZGUodmFsKTsvL2NoZWNrIG11dGF0aW9uIG5vZGVcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwodmFsLnF1ZXJ5U2VsZWN0b3JBbGwoY2xhc3NTZWxlY3RvciksIGNoZWNrTm9kZSk7Ly9xdWVyeSBhbGwgbm9kZXMgd2l0aCByZXF1aXJlZCBjbGFzc2VzIGFuZCBjaGVjayBpdFxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0b3AgbGlzdGVuaW5nIHRoZSBkb20gY2hhbmdlc1xyXG4gKi9cclxuRG9tTXV0YXRpb25zLnByb3RvdHlwZS5zdG9wT2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb21NdXRhdGlvbnM7XHJcblxyXG5cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogRXZlbnRzIHN5c3RlbS5cclxuICogQHBhcmFtIHtBcnJheX0gYWxsb3dlZEV2ZW50cyBhcnJheSBvZiBhbGxvd2VkIGV2ZW50cy5cclxuICogQGNvbnN0cnVjdHMgRXZlbnRzXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vYWxsb3cgdG8gd29yayB3aXRoIGFsbCBldmVudHNcclxuICogdmFyIGV2ZW50cyA9IG5ldyBFdmVudHMoKTtcclxuICogZXZlbnRzLm9uKFwibXlCZXN0RXZlbnRcIixmdW5jdGlvbihlKXtjb25zb2xlLmxvZyhlKX0pO1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL0FsbG93IHRvIHNlcnZlIG9ubHkgbGltaXRlZCBldmVudHNcclxuICogIHZhciBldmVudHMgPSBuZXcgRXZlbnRzKFtcImJlZm9yZVN1Ym1pdFwiLFwib25EYXRhUmVhZHlcIl0pO1xyXG4gKiAgZXZlbnRzLm9uKFwibXlCZXN0RXZlbnRcIixmdW5jdGlvbihlKXtjb25zb2xlLmxvZyhlKX0pOy8vd2lsbCBub3Qgd29ya3NcclxuICogIGV2ZW50cy5vbihcImJlZm9yZVN1Ym1pdFwiLGZ1bmN0aW9uKGUpe2NvbnNvbGUubG9nKGUpfSk7Ly93aWxsIHdvcmtcclxuICovXHJcbnZhciBFdmVudHMgPSBmdW5jdGlvbiAoYWxsb3dlZEV2ZW50cykge1xyXG4gICAgdGhpcy5fc3RvcmFnZSA9IHt9O1xyXG4gICAgdGhpcy5fYWxsb3dlZEV2ZW50cyA9IGFsbG93ZWRFdmVudHM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGV2ZW50KHMpXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgZXZlbnQgb3Igc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IGxpc3RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cclxuICogQGV4YW1wbGVcclxuICogdmFyIGV2ZW50cyA9IG5ldyBFdmVudHMoKTtcclxuICogZXZlbnRzLm9uKFwibXlCZXN0RXZlbnQgbXlCZXN0RXZlbnQyIG15QmVzdEV2ZW50M1wiLGZ1bmN0aW9uKGUpe2NvbnNvbGUubG9nKGUpfSk7XHJcbiAqIGV2ZW50cy5vbihcIm15QmVzdEV2ZW50XCIsZnVuY3Rpb24oZSl7Y29uc29sZS5sb2coZSl9KTtcclxuICovXHJcbkV2ZW50cy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnRzLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGV2ZW50QXJyID0gZXZlbnRzLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpLnNwbGl0KFwiIFwiKTtcclxuICAgIGV2ZW50QXJyLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIGlmICh0aGlzLl9hbGxvd2VkRXZlbnRzICAmJiB0aGlzLl9hbGxvd2VkRXZlbnRzLmluZGV4T2YoZXZlbnQpID09PSAtMSl7Ly8gZXZlbnQgbm90IGluc2lkZSBhbGxvd2VkIGV2ZW50c1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFdmVudHMuIFRyeSB0byByZWdpc3RlciBldmVudCAlcywgYnV0IGV2ZW50IGlzIG5vdCBhbGxvd2VkXCIsZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fc3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShldmVudHMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2VbZXZlbnRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3N0b3JhZ2VbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfSx0aGlzKVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEFkZCBhY3Rpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXHJcbiAqIEBkZXByZWNhdGVkICB1c2UgXCJvblwiIGluc3RlYWRcclxuICovXHJcbkV2ZW50cy5wcm90b3R5cGUucmVnaXN0ZXJBY3Rpb24gPSBFdmVudHMucHJvdG90eXBlLm9uO1xyXG5cclxuXHJcbi8qKlxyXG4gKiByZW1vdmUgZXZlbnRcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqL1xyXG5FdmVudHMucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcclxuICAgIGFsZXJ0KFwiWW91IHRyeSB0byByZW1vdmUgYWN0aW9uLiBUaGlzIHBhcnQgaXMgaW5jb21wbGV0ZVwiKTtcclxuICAgIC8vVE9ET1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyaWdnZXIgZXZlbnQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBldmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgZXZlbnRzID0gbmV3IEV2ZW50cygpO1xyXG4gKiBldmVudHMub24oXCJteUJlc3RFdmVudFwiLGZ1bmN0aW9uKGUpe2NvbnNvbGUubG9nKGUuYmVzdEtleSl9KTtcclxuICogZXZlbnRzLnRyaWdnZXIoXCJteUJlc3RFdmVudFwiLHtiZXN0S2V5OjQyfSk7IC8vd2lsbCBzaG93IGluIGxvZ1xyXG4gKi9cclxuRXZlbnRzLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XHJcbiAgICBpZiAodGhpcy5fYWxsb3dlZEV2ZW50cyAgJiYgdGhpcy5fYWxsb3dlZEV2ZW50cy5pbmRleE9mKGV2ZW50KSA9PT0gLTEpey8vIGV2ZW50IG5vdCBpbnNpZGUgYWxsb3dlZCBldmVudHNcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJFdmVudHMuIFRyeSB0byB0cmlnZ2VyIGV2ZW50ICVzLCBidXQgZXZlbnQgaXMgbm90IGFsbG93ZWRcIixldmVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX3N0b3JhZ2UuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbiA9IDAsIGwgPSB0aGlzLl9zdG9yYWdlW2V2ZW50XS5sZW5ndGg7IG4gPCBsOyBuKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcmFnZVtldmVudF1bbl0ob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm0gYWN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IFthY3Rpb25QYXJhbXNdIG9iamVjdCB3aXRoIGFsbCBhY3Rpb24gZGF0YSBmcm9tIHNlcnZlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGFqYXggb3B0aW9uc1xyXG4gKiBAZGVwcmVjYXRlZCB1c2UgXCJ0cmlnZ2VyXCIgaW5zdGVhZFxyXG4gKi9cclxuRXZlbnRzLnByb3RvdHlwZS5wZXJmb3JtQWN0aW9uID0gRXZlbnRzLnByb3RvdHlwZS50cmlnZ2VyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogSW5zdGFuY2UgY29udHJvbGxlclxyXG4gKiBAcGFyYW0gc3BpcmFsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEluc3RhbmNlc0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoc3BpcmFsKSB7XHJcbiAgICB0aGlzLnNwaXJhbCA9IHNwaXJhbDtcclxuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvcil7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlBsZWFzZSBjYWxsIEluc3RhbmNlc0NvbnRyb2xsZXIgd2l0aCBuZXcgIC0gJ25ldyBJbnN0YW5jZXNDb250cm9sbGVyKCknIFwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zdG9yYWdlID0ge1xyXG4gICAgICAgIGluc3RhbmNlc0NvbnN0cnVjdG9yczoge1xyXG4gICAgICAgICAgICBjc3NDbGFzc2VzOnt9LFxyXG4gICAgICAgICAgICBqc0NvbnN0cnVjdG9yczp7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkb25zOiB7fSxcclxuICAgICAgICBpbnN0YW5jZXM6IHt9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vdG9kbyBkZWNpZGUgaWYgd2UgbmVlZCB0aGlzXHJcbiAgICAvL1tcIm9uQWRkSW5zdGFuY2VcIiwgXCJvblJlbW92ZUluc3RhbmNlXCJdXHJcbiAgICAvL3RoaXMuZXZlbnRzID0gbmV3IHNwaXJhbC5tb2R1bGVzLmNvcmUuRXZlbnRzKCk7XHJcbn07XHJcbi8qKlxyXG4gKiBSZWdpc3RlciBuZXcgaW5zdGFuY2UgdHlwZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvckZ1bmN0aW9uIC0gY29uc3RydWN0b3IgZnVuY3Rpb24gb2YgaW5zdGFuY2VcclxuICogQHBhcmFtIHtTdHJpbmd9IFtjc3NDbGFzc05hbWVdIC0gY3NzIGNsYXNzIG5hbWUgb2YgaW5zdGFuY2UuIElmIGNsYXNzIG5vdCBwcm92aWRlZCB0aGF0IGl0IGNhbid0IGJlIGF1dG9tYXRpY2FsbHkgY29udHJvbGxlZCBieSBEb21NdXRhdGlvbi4gQnV0IHlvdSBzdGlsbCBjYW4gdXNlIGl0IGZyb20gSlMuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2tpcEluaXRpYWxpemF0aW9uPWZhbHNlXSAgLSBza2lwIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiwganVzdCBhZGRpbmcsIG5vIGluaXQgbm9kZXMuXHJcbiAqL1xyXG5JbnN0YW5jZXNDb250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3Rlckluc3RhbmNlVHlwZSA9IGZ1bmN0aW9uIChjb25zdHJ1Y3RvckZ1bmN0aW9uLCBjc3NDbGFzc05hbWUsIGlzU2tpcEluaXRpYWxpemF0aW9uKSB7XHJcbiAgICB2YXIgaW5zdGFuY2VOYW1lID0gY29uc3RydWN0b3JGdW5jdGlvbi5wcm90b3R5cGUubmFtZTtcclxuXHJcbiAgICBpZiAoIWluc3RhbmNlTmFtZSl7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkluc3RhbmNlIGNvbnN0cnVjdG9yIHNob3VsZCBoYXZlIG5hbWUgaW5zaWRlIGl0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zdG9yYWdlLmluc3RhbmNlc0NvbnN0cnVjdG9ycy5qc0NvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eShpbnN0YW5jZU5hbWUpKXtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSW5zdGFuY2UgQ29uc3RydWN0b3IgZm9yIHR5cGUgJyVzJyBhbHJlYWR5IGFkZGVkLiBTa2lwcGluZ1wiLGluc3RhbmNlTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjc3NDbGFzc05hbWUpey8vYWRkIGxpbmsgKGNzc0NsYXNzTmFtZS0+aW5zdGFuY2VOYW1lKVxyXG4gICAgICAgIHRoaXMuX3N0b3JhZ2UuaW5zdGFuY2VzQ29uc3RydWN0b3JzLmNzc0NsYXNzZXNbY3NzQ2xhc3NOYW1lXSA9IGluc3RhbmNlTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zdG9yYWdlLmluc3RhbmNlc0NvbnN0cnVjdG9ycy5qc0NvbnN0cnVjdG9yc1tpbnN0YW5jZU5hbWVdID0gY29uc3RydWN0b3JGdW5jdGlvbjtcclxuXHJcblxyXG5cclxuICAgIC8vIGlmICh0aGlzLl9zdG9yYWdlLmluc3RhbmNlc0NvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc05hbWUpKXtcclxuICAgIC8vICAgIGNvbnNvbGUuZXJyb3IoXCJJbnN0YW5jZSBDb25zdHJ1Y3RvciBmb3IgdHlwZSAlcyBhbHJlYWR5IGFkZGVkLiBTa2lwcGluZ1wiLGNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUpO1xyXG4gICAgLy8gICAgcmV0dXJuO1xyXG4gICAgLy99XHJcbiAgICAvL3RoaXMuX3N0b3JhZ2UuaW5zdGFuY2VzQ29uc3RydWN0b3JzW2NsYXNzTmFtZV0gPSB7Ly9pbml0IHN0b3JhZ2UgZmllbGRzXHJcbiAgICAvLyAgICBcInR5cGVOYW1lXCI6IGNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUsXHJcbiAgICAvLyAgICBcImNvbnN0cnVjdG9yXCI6IGNvbnN0cnVjdG9yRnVuY3Rpb25cclxuICAgIC8vfTtcclxuICAgIHRoaXMuX3N0b3JhZ2UuaW5zdGFuY2VzW2luc3RhbmNlTmFtZV0gPSBbXTtcclxuICAgIGlmICghaXNTa2lwSW5pdGlhbGl6YXRpb24pe1xyXG4gICAgICAgIHZhciBub2RlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY3NzQ2xhc3NOYW1lKTsvL2luaXQgYWRkIG5vZGVzIHdpdGggdGhpcyBjbGFzc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBub2Rlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEluc3RhbmNlKGluc3RhbmNlTmFtZSwgbm9kZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogT2xkIG1ldGhvZCB0byByZWdpc3RlciBpbnN0YW5jZSB0eXBlXHJcbiAqIEBwYXJhbSBjbGFzc05hbWVcclxuICogQHBhcmFtIGNvbnN0cnVjdG9yRnVuY3Rpb25cclxuICogQHBhcmFtIGlzU2tpcEluaXRpYWxpemF0aW9uXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5JbnN0YW5jZXNDb250cm9sbGVyLnByb3RvdHlwZS5hZGRJbnN0YW5jZVR5cGUgPWZ1bmN0aW9uKGNsYXNzTmFtZSxjb25zdHJ1Y3RvckZ1bmN0aW9uLCBpc1NraXBJbml0aWFsaXphdGlvbil7XHJcbiAgICBjb25zb2xlLndhcm4oXCJhZGRJbnN0YW5jZVR5cGUgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSByZWdpc3Rlckluc3RhbmNlVHlwZSBpbnN0ZWFkXCIpO1xyXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJJbnN0YW5jZVR5cGUoY29uc3RydWN0b3JGdW5jdGlvbiwgaXNTa2lwSW5pdGlhbGl6YXRpb24pO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBZGQgaW5zdGFuY2VcclxuICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlTmFtZSAtIG5hbWUgb2YgaW5zdGFuY2VcclxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgLSBkb20gbm9kZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGFsbCBvcHRpb25zIGZvciBzZW5kIHRvIHRoZSBjb25zdHJ1Y3RvclxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkluc3RhbmNlc0NvbnRyb2xsZXIucHJvdG90eXBlLmFkZEluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlTmFtZSwgbm9kZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGluc3RhbmNlQ29uc3RydWN0b3IgPSB0aGlzLl9zdG9yYWdlLmluc3RhbmNlc0NvbnN0cnVjdG9ycy5qc0NvbnN0cnVjdG9yc1tpbnN0YW5jZU5hbWVdLFxyXG4gICAgICAgIGlzQWxyZWFkeUFkZGVkID0gdGhpcy5nZXRJbnN0YW5jZShpbnN0YW5jZU5hbWUsbm9kZSk7XHJcbiAgICBpZiAoIWluc3RhbmNlQ29uc3RydWN0b3IgfHwgaXNBbHJlYWR5QWRkZWQpIHsvL2lmIG5vdCBmb3VuZCB0aGlzIHR5cGUgIG9yIGFscmVhZHkgYWRkZWQgLSByZXR1cm5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbi8vICAgIGNvbnNvbGUubG9nKFwiQWRkaW5nIGluc3RhbmNlIGZvciB0eXBlIC1cIixpbnN0YW5jZU5hbWUsXCIuIE5vZGUgLSBcIixub2RlKTtcclxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBpbnN0YW5jZUNvbnN0cnVjdG9yKHRoaXMuc3BpcmFsLG5vZGUsIG9wdGlvbnMpO1xyXG4gICAgdGhpcy5fc3RvcmFnZS5pbnN0YW5jZXNbaW5zdGFuY2VOYW1lXS5wdXNoKHsvL2FkZCBuZXcgaW5zdGFuY2Ugb2YgdGhpcyB0eXBlXHJcbiAgICAgICAgXCJub2RlXCI6IG5vZGUsXHJcbiAgICAgICAgXCJpbnN0YW5jZVwiOiBpbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy90aGlzLmV2ZW50cy50cmlnZ2VyKFwib25BZGRJbnN0YW5jZVwiLCBpbnN0YW5jZSk7XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG59O1xyXG4vKipcclxuICogUmVtb3ZlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VOYW1lIC0gbmFtZSBvZiBpbnN0YW5jZSBjbGFzc1xyXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5vZGUgLSBkb20gbm9kZSBJRFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkluc3RhbmNlc0NvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlTmFtZSwgbm9kZSkge1xyXG4gICAgdmFyIGluc3RhbmNlT2JqID0gdGhpcy5nZXRJbnN0YW5jZShpbnN0YW5jZU5hbWUsIG5vZGUsdHJ1ZSksXHJcbiAgICAgICAga2V5O1xyXG4gICAgaWYgKCFpbnN0YW5jZU9iaikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlT2JqLmluc3RhbmNlLmRpZSgpOy8vYXZvaWQgbWVtb3J5IGxlYWtcclxuICAgIGtleSA9IHRoaXMuX3N0b3JhZ2UuaW5zdGFuY2VzW2luc3RhbmNlTmFtZV0uaW5kZXhPZihpbnN0YW5jZU9iaik7XHJcbiAgICBpZiAoa2V5ICE9PSAtMSl7Ly9yZW1vdmUga2V5XHJcbiAgICAgICAgdGhpcy5fc3RvcmFnZS5pbnN0YW5jZXNbaW5zdGFuY2VOYW1lXS5zcGxpY2Uoa2V5LCAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuICogR2V0IGluc3RhbmNlLiBSZXR1cm4gaW5zdGFuY2Ugb2JqZWN0IG9mIHRoaXMgZG9tIG5vZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlTmFtZSAtIG5hbWUgb2YgaW5zdGFuY2VcclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBub2RlIC0gZG9tIG5vZGUgbyBkb21lIG5vZGUgSURcclxuICogQHBhcmFtIHtib29sZWFufSBbaXNSZXR1cm5PYmplY3RdIC0gcmV0dXJuIG9iamVjdCBvciBpbnN0YW5jZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkluc3RhbmNlc0NvbnRyb2xsZXIucHJvdG90eXBlLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlTmFtZSwgbm9kZSwgaXNSZXR1cm5PYmplY3QpIHsvL1RPRE8gaXNSZXR1cm5PYmplY3Qgbm90IG5lZWRlZC4gUmVmYWN0b3IgYW5kIHJlbW92ZVxyXG4gICAgdmFyIHR5cGVBcnIgPSB0aGlzLl9zdG9yYWdlLmluc3RhbmNlc1tpbnN0YW5jZU5hbWVdLFxyXG4gICAgICAgIHJldCA9IGZhbHNlO1xyXG4gICAgaWYgKCF0eXBlQXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbm9kZSA9IChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpID8gbm9kZSA6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUpO1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IHR5cGVBcnIubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKykgey8vaXRlcmF0ZSBzdG9yYWdlIGFuZCB0cnkgdG8gZmluZCBpbnN0YW5jZVxyXG4gICAgICAgIGlmICh0eXBlQXJyW2tleV0ubm9kZSA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICByZXQgPSAoaXNSZXR1cm5PYmplY3QpID8gdHlwZUFycltrZXldIDogdHlwZUFycltrZXldLmluc3RhbmNlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59O1xyXG4vKipcclxuICogR2V0IGluc3RhbmNlcy4gUmV0dXJuIGFycmF5IG9mIGluc3RhbmNlcyBvYmplY3RzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZU5hbWUgLSBuYW1lIG9mIGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHthcnJheXxib29sZWFufVxyXG4gKi9cclxuSW5zdGFuY2VzQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SW5zdGFuY2VzID0gZnVuY3Rpb24gKGluc3RhbmNlTmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuaW5zdGFuY2VzW2luc3RhbmNlTmFtZV0gfHwgZmFsc2U7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGFkZG9uIGZvciBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWRkb25cclxuICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlTmFtZSBuYW1lIG9mIGluc3RhbmNlIHRvIHJlZ2lzdGVyIGFkZG9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRvblR5cGUgdHlwZSBvZiBhZGRvbiAobWVzc2FnZSxmaWxsLGV0YylcclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZG9uTmFtZSBuYW1lIG9mIGFkZG9uIChzcGlyYWwsIGJvb3RzdHJhcCxldGMpXHJcbiAqL1xyXG5JbnN0YW5jZXNDb250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3RlckFkZG9uID0gZnVuY3Rpb24oYWRkb24sIGluc3RhbmNlTmFtZSwgYWRkb25UeXBlLCBhZGRvbk5hbWUpe1xyXG4gICAgaWYgKCF0aGlzLl9zdG9yYWdlLmFkZG9ucy5oYXNPd25Qcm9wZXJ0eShpbnN0YW5jZU5hbWUpKXtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlLmFkZG9uc1tpbnN0YW5jZU5hbWVdID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuX3N0b3JhZ2UuYWRkb25zW2luc3RhbmNlTmFtZV0uaGFzT3duUHJvcGVydHkoYWRkb25UeXBlKSl7XHJcbiAgICAgICAgdGhpcy5fc3RvcmFnZS5hZGRvbnNbaW5zdGFuY2VOYW1lXVthZGRvblR5cGVdID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fc3RvcmFnZS5hZGRvbnNbaW5zdGFuY2VOYW1lXVthZGRvblR5cGVdLmhhc093blByb3BlcnR5KGFkZG9uTmFtZSkpe1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgJXMgYWRkb24gdHlwZSAlcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIGluc3RhbmNlICVzISBTa2lwcGluZyByZWdpc3RyYXRpb24uXCIsYWRkb25OYW1lLGFkZG9uVHlwZSxpbnN0YW5jZU5hbWUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX3N0b3JhZ2UuYWRkb25zW2luc3RhbmNlTmFtZV1bYWRkb25UeXBlXVthZGRvbk5hbWVdPSBhZGRvbjtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHJlZ2lzdGVyZWQgYWRkb25cclxuICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlTmFtZSBuYW1lIG9mIGluc3RhbmNlIHRvIHJlZ2lzdGVyIGFkZG9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRvblR5cGUgdHlwZSBvZiBhZGRvbiAobWVzc2FnZSxmaWxsLGV0YylcclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZG9uTmFtZSBuYW1lIG9mIGFkZG9uIChzcGlyYWwsIGJvb3RzdHJhcCxldGMpXHJcbiAqL1xyXG5JbnN0YW5jZXNDb250cm9sbGVyLnByb3RvdHlwZS5nZXRJbnN0YW5jZUFkZG9uID1mdW5jdGlvbihpbnN0YW5jZU5hbWUsIGFkZG9uVHlwZSwgYWRkb25OYW1lKXtcclxuICAgIGlmICghdGhpcy5fc3RvcmFnZS5hZGRvbnMuaGFzT3duUHJvcGVydHkoaW5zdGFuY2VOYW1lKSB8fCAhdGhpcy5fc3RvcmFnZS5hZGRvbnNbaW5zdGFuY2VOYW1lXS5oYXNPd25Qcm9wZXJ0eShhZGRvblR5cGUpIHx8ICF0aGlzLl9zdG9yYWdlLmFkZG9uc1tpbnN0YW5jZU5hbWVdW2FkZG9uVHlwZV0uaGFzT3duUHJvcGVydHkoYWRkb25OYW1lKSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuYWRkb25zW2luc3RhbmNlTmFtZV1bYWRkb25UeXBlXVthZGRvbk5hbWVdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXQgYWxsIHJlZ2lzdGVyZWQgY2xhc3Nlc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5JbnN0YW5jZXNDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGFzc2VzID0gZnVuY3Rpb24gKCl7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3RvcmFnZS5pbnN0YW5jZXNDb25zdHJ1Y3RvcnMuY3NzQ2xhc3Nlcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yIGdpdmVuIGNzc0NsYXNzIHJldHVybiBuYW1lIG9mIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3NDbGFzc1xyXG4gKiBAcmV0dXJuIHsqfVxyXG4gKi9cclxuSW5zdGFuY2VzQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SW5zdGFuY2VOYW1lQnlDc3NDbGFzcyA9IGZ1bmN0aW9uKGNzc0NsYXNzKXtcclxuICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmluc3RhbmNlc0NvbnN0cnVjdG9ycy5jc3NDbGFzc2VzW2Nzc0NsYXNzXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgY29uc3RydWN0b3IgYnkgbmFtZSBvciBjbGFzcyBuYW1lXHJcbiAqL1xyXG5JbnN0YW5jZXNDb250cm9sbGVyLnByb3RvdHlwZS5nZXRJbnN0YW5jZUNvbnN0cnVjdG9ycyA9IGZ1bmN0aW9uIChuYW1lKXtcclxuXHJcbiAgIC8vVE9ET1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnN0YW5jZXNDb250cm9sbGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHBsdWdpbiBhZGRzIGFiaWxpdHkgdG8gcGVyZm9ybSBhY3Rpb25zIGZyb20gdGhlIHNlcnZlci5cclxuICogXCJhY3Rpb25cIjpcInJlbG9hZFwiXHJcbiAqIFwiYWN0aW9uXCI6e1wicmVkaXJlY3RcIjpcIi9hY2NvdW50XCJ9XHJcbiAqIFwiYWN0aW9uXCI6e1wicmVkaXJlY3RcIjpcIi9hY2NvdW50XCIsXCJkZWxheVwiOjMwMDB9XHJcbiAqIFwiYWN0aW9uXCI6e1wibmFtZVwiOlwicmVkaXJlY3RcIixcInVybFwiOlwiL2FjY291bnRcIixcImRlbGF5XCI6MzAwMH1cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNmKSB7XHJcbiAgICBzZi5hamF4LmV2ZW50cy5vbignbG9hZCcsIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcclxuICAgICAgICBpZiAocmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ2FjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYWN0aW9uID09PSAnc3RyaW5nJykgey8vXCJhY3Rpb25cIjpcInJlbG9hZFwiXHJcbiAgICAgICAgICAgICAgICBzZi5ldmVudHMudHJpZ2dlcihyZXNwb25zZS5hY3Rpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5hY3Rpb24gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc3BvbnNlLmFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKCdmbGFzaCcpICE9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsYXNoID0gcmVzcG9uc2UuYWN0aW9uWydmbGFzaCddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZkZsYXNoTWVzc2FnZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYWN0aW9uWydmbGFzaCddID09PSAnb2JqZWN0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmRmxhc2hNZXNzYWdlID0gZmxhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmRmxhc2hNZXNzYWdlLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZkZsYXNoTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZsYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdzZkZsYXNoTWVzc2FnZScsIEpTT04uc3RyaW5naWZ5KHNmRmxhc2hNZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKCdyZWRpcmVjdCcpICE9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmLmV2ZW50cy50cmlnZ2VyKCdyZWRpcmVjdCcsIHJlc3BvbnNlLmFjdGlvblsncmVkaXJlY3QnXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgK3Jlc3BvbnNlLmFjdGlvbi5kZWxheXwwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5cy5pbmRleE9mKCduYW1lJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmLmV2ZW50cy50cmlnZ2VyKHJlc3BvbnNlLmFjdGlvbi5uYW1lLCByZXNwb25zZS5hY3Rpb24udXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCArcmVzcG9uc2UuYWN0aW9uLmRlbGF5IHx8IDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9pZiAoa2V5cy5sZW5ndGggPT09IDEpIHsvL1wiYWN0aW9uXCI6e1wicmVkaXJlY3RcIjpcIi9hY2NvdW50XCJ9XHJcbiAgICAgICAgICAgICAgICAvLyAgICBzZi5ldmVudHMudHJpZ2dlcihrZXlzWzBdLCByZXNwb25zZS5hY3Rpb25ba2V5c1swXV0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgLy99IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAyICYmIHJlc3BvbnNlLmFjdGlvbi5kZWxheSkgey8vXCJhY3Rpb25cIjp7XCJyZWRpcmVjdFwiOlwiL2FjY291bnRcIixcImRlbGF5XCI6MzAwMH1cclxuICAgICAgICAgICAgICAgIC8vICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHZhciBhY3Rpb24gPSBrZXlzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAnZGVsYXknO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIH0pWzBdO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHNmLmV2ZW50cy50cmlnZ2VyKGFjdGlvbiwgcmVzcG9uc2UuYWN0aW9uW2FjdGlvbl0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgfSwgK3Jlc3BvbnNlLmFjdGlvbi5kZWxheSk7XHJcbiAgICAgICAgICAgICAgICAvL30gZWxzZSBpZiAoa2V5cy5sZW5ndGggPiAxKSB7Ly9cImFjdGlvblwiOntcIm5hbWVcIjpcInJlZGlyZWN0XCIsXCJ1cmxcIjpcIi9hY2NvdW50XCIsXCJkZWxheVwiOjMwMDB9XHJcbiAgICAgICAgICAgICAgICAvLyAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICBzZi5ldmVudHMudHJpZ2dlcihyZXNwb25zZS5hY3Rpb24ubmFtZSwgcmVzcG9uc2UuYWN0aW9uLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIC8vICAgIH0sICtyZXNwb25zZS5hY3Rpb24uZGVsYXkgfHwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL30gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICBjb25zb2xlLmVycm9yKFwiQWN0aW9uIGZyb20gc2VydmVyLiBPYmplY3QgZG9lc24ndCBoYXZlIGtleXMuIFwiLCByZXNwb25zZS5hY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQWN0aW9uIGZyb20gc2VydmVyLiBTb21ldGhpbmcgd3JvbmcuIFwiLCByZXNwb25zZS5hY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAoZnVuY3Rpb24gKHNmRmxhc2hNZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFzZkZsYXNoTWVzc2FnZSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBtZXNzYWdlICA9IEpTT04ucGFyc2Uoc2ZGbGFzaE1lc3NhZ2UpLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBub2RlV3JhcHBlcixcclxuICAgICAgICAgICAgZmxhc2hDbGFzcztcclxuICAgICAgICBpZiAodGltZXN0YW1wIC0gbWVzc2FnZS50aW1lc3RhbXAgPiAxMDAwMCkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdkZWJ1ZycgfHwgbWVzc2FnZS50eXBlID09PSAnc3VjY2Vzcycpe1xyXG4gICAgICAgICAgICBmbGFzaENsYXNzID0gJ2RlYnVnJ1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAnaW5mbycgfHwgIW1lc3NhZ2UudHlwZSB8fCBtZXNzYWdlLnR5cGUgPT09ICdub3RpY2UnKXtcclxuICAgICAgICAgICAgZmxhc2hDbGFzcyA9ICdpbmZvJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZsYXNoQ2xhc3MgPSAnZGFuZ2VyJ1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbm9kZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBub2RlV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdmbGFzaC13cmFwcGVyJyk7XHJcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdmbGFzaCcsIGZsYXNoQ2xhc3MpO1xyXG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gbWVzc2FnZS5tZXNzYWdlO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZVdyYXBwZXIpO1xyXG4gICAgICAgIG5vZGVXcmFwcGVyLmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtub2RlV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7fSwgMSk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe25vZGVXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKX0sIG1lc3NhZ2UudGltZW91dHx8NTAwMCk7XHJcblxyXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3NmRmxhc2hNZXNzYWdlJyk7XHJcbiAgICB9KHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3NmRmxhc2hNZXNzYWdlJykpKVxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXZlbnRzKXtcclxuICAgIGV2ZW50cy5vbihcInJlZGlyZWN0XCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciB1cmwgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXZlbnQpID09PSBcIltvYmplY3QgU3RyaW5nXVwiID8gZXZlbnQgOiBldmVudC51cmw7XHJcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjg3MDk5L2hvdy10by10ZXN0LWlmLWEtdXJsLXN0cmluZy1pcy1hYnNvbHV0ZS1vci1yZWxhdGl2ZVxyXG4gICAgICAgIHNlbGYubG9jYXRpb25bL14oPzpbYS16XSs6KT9cXC9cXC8vaS50ZXN0KHVybCkgPyAnaHJlZicgOiAncGF0aG5hbWUnXSA9IHVybDtcclxuICAgIH0pO1xyXG5cclxuICAgIGV2ZW50cy5vbigncmVsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXZlbnRzLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGV2ZW50cy50cmlnZ2VyKCdyZWxvYWQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGV2ZW50cy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgfSk7XHJcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gbWFuaXB1bGF0ZSBET00gRXZlbnRzLiBJdCdzIGEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIFwiYWRkRXZlbnRMaXN0ZW5lclwiIGJ1dCBpdCdzIHN0b3JlIGFsbCBmdW5jdGlvbnMgYW5kIGFsbG93IHVzIHRvIHJlbW92ZSBpdCBhbGwuXHJcbiAqIEl0J3MgdmVyeSBoZWxwZnVsIGZvciBkaWUoKSBtZXRob2Qgb2YgaW5zdGFuY2VzXHJcbiAqIEBUT0RPIGFkZCB0byBtYW55IG5vZGVzXHJcbiAqIEBUT0RPIG5ldyBtZXRob2QgbGlrZSBhZGRFdmVudExpc3RlbmVyICBET01FdmVudHMub24obm9kZShzKSxldmVudCxjYWxsYmFjayx1c2VDYXB0dXJlKTtcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRE9NRXZlbnRzID0gZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgc3RvcmFnZSBmb3IgZXZlbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxPYmplY3Q+fSBET01FdmVudHMgLSBkb20gZXZlbnRzIGFycmF5XHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gRE9NRXZlbnRzLkRPTU5vZGUgLSAgIERPTSBub2RlXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gRE9NRXZlbnRzLmV2ZW50VHlwZSAtICAgRXZlbnQgdHlwZVxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gRE9NRXZlbnRzLmV2ZW50RnVuY3Rpb24gLSAgIEZ1bmN0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IERPTUV2ZW50cy51c2VDYXB0dXJlPWZhbHNlIC0gICB1c2VDYXB0dXJlXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLi4uIC0gICBhbm90aGVyIG9iamVjdFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fRE9NRXZlbnRzU3RvcmFnZSA9IFtdO1xyXG59O1xyXG4vKipcclxuICogQWRkIGV2ZW50KHMpIHRvIG5vZGUocykuXHJcbiAqIEBUT0RPIGFkZCB0byBtYW55IG5vZGVzXHJcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58T2JqZWN0fSBldmVudEFycmF5IC0gZXZlbnQgYXJyYXkgb3IgZXZlbnQgaXRzZWxmXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFycmF5LkRPTU5vZGUgLSAgIERPTSBub2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudEFycmF5LmV2ZW50VHlwZSAtICAgRXZlbnQgdHlwZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEFycmF5LmV2ZW50RnVuY3Rpb24gLSAgIEZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2V2ZW50QXJyYXkudXNlQ2FwdHVyZT1mYWxzZV0gLSAgIHVzZUNhcHR1cmVcclxuICogQGV4YW1wbGVcclxuICogdmFyIERPTUV2ZW50c0luc3RhbmNlID0gbmV3IERPTUV2ZW50cygpO1xyXG4gKiB2YXIgZXZlbnRPbmUgPSB7XHJcbiAqICAgICAgRE9NTm9kZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleGFtcGxlXCIpLFxyXG4gKiAgICAgIGV2ZW50VHlwZTogXCJjbGlja1wiLFxyXG4gKiAgICAgIGV2ZW50RnVuY3Rpb246IGZ1bmN0aW9uIChlKSB7XHJcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiSGkgdGhlcmUuIE5hdGl2ZSAgRE9NIGV2ZW50cyBpczpcIixlKTtcclxuICogICAgICB9XHJcbiAqIH1cclxuICogIHZhciBldmVudFR3byA9IHtcclxuICogICAgICBET01Ob2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV4YW1wbGUyXCIpLFxyXG4gKiAgICAgIGV2ZW50VHlwZTogXCJtb3VzZWRvd25cIixcclxuICogICAgICBldmVudEZ1bmN0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhcIkhpIHRoZXJlLiBtb3VzZWRvd24gZXZlbnQuIE5hdGl2ZSAgRE9NIGV2ZW50cyBpczpcIixlKTtcclxuICogICAgICB9XHJcbiAqIH1cclxuICogIERPTUV2ZW50c0luc3RhbmNlLmFkZChbZXZlbnRPbmUsZXZlbnRUd29dKTtcclxuICovXHJcbkRPTUV2ZW50cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZXZlbnRBcnJheSl7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKXtcclxuICAgICAgICBldmVudEFycmF5ID0gW2V2ZW50QXJyYXldO1xyXG4gICAgfVxyXG4gICAgZXZlbnRBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCl7XHJcbiAgICAgICAgdmFsLnVzZUNhcHR1cmU9ISEodmFsLnVzZUNhcHR1cmUpO1xyXG4gICAgICAgIHZhbC5ET01Ob2RlLmFkZEV2ZW50TGlzdGVuZXIodmFsLmV2ZW50VHlwZSx2YWwuZXZlbnRGdW5jdGlvbix2YWwudXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgdGhpcy5fRE9NRXZlbnRzU3RvcmFnZS5wdXNoKHZhbCk7XHJcbiAgICB9LHRoaXMpXHJcbn07XHJcbi8qKlxyXG4gKiBSZW1vdmUgZXZlbnRzXHJcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGV2ZW50QXJyYXkgLSBldmVudCBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcnJheS5ET01Ob2RlIC0gICBET00gbm9kZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRBcnJheS5ldmVudFR5cGUgLSAgIEV2ZW50IHR5cGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRBcnJheS5ldmVudEZ1bmN0aW9uIC0gICBGdW5jdGlvblxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtldmVudEFycmF5LnVzZUNhcHR1cmU9ZmFsc2VdIC0gICB1c2VDYXB0dXJlXHJcbiAqL1xyXG5ET01FdmVudHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50QXJyYXkpe1xyXG4vL1RPRE8gSU1QTEVNRU5UXHJcbiAgICAvLyBUT0RPINC90LUg0YPQstC10YDQtdC9INGH0YLQviDRjdGC0L7RgiDQvNC10YLQvtC0INC90LXQvtCx0YXQvtC00LjQvC4g0LXRgdC70Lgg0L3QsNC00L4g0YfQsNGB0YLQviDRg9Cx0LjRgNCw0YLRjCDQutCw0LrQuNC10YLQviDQvtCx0YDQsNCx0L7RgtGH0LjQutC4LCDRgtC+INC70YPRh9GI0LUg0L/QvtGB0YLQsNCy0LjRgtGMINC+0LHRgNCw0LHQvtGC0YfQutC4INC90LAg0YDQvtC00LjRgtC10LvRj1xyXG4gICAgY29uc29sZS53YXJuKFwiVE9ETyBJTVBMRU1FTlRcIik7XHJcblxyXG59O1xyXG4vKipcclxuICogUmVtb3ZlIGFsbCBkb20gZXZlbnRzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGluc3RhbmNlIChhZGRlZCBieSBtZXRob2QgYWRkKVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL2xvb2sgYXQgYWRkIG1ldGhvZCBhcyBmaXJzdCBwYXJ0IG9mIHRoaXMgY29kZVxyXG4gKiBET01FdmVudHNJbnN0YW5jZS5yZW1vdmVBbGwoKTtcclxuICovXHJcbkRPTUV2ZW50cy5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuX0RPTUV2ZW50c1N0b3JhZ2UuZm9yRWFjaChmdW5jdGlvbih2YWwpe1xyXG4gICAgICAgIHZhbC5ET01Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodmFsLmV2ZW50VHlwZSx2YWwuZXZlbnRGdW5jdGlvbix2YWwudXNlQ2FwdHVyZSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX0RPTUV2ZW50c1N0b3JhZ2U9W107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTUV2ZW50czsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG9iamVjdCB0cnkgdG8gYmUgZWFzeSBhcyBGb3JtRGF0YS5cclxuICogUGxlYXNlIG5vdGUgdGhpcyBpcyBub3QoISkgYSBzaGltIGZvciBGb3JtIGRhdGEsIGJlY2F1c2UgaXQncyBpbXBvc3NpYmxlICh5b3Ugc2hvdWxkIHNldCBoZWFkZXJzIGZvciBBamF4IGJ5IGhhbmRzKVxyXG4gKiBJdCB0YWtlIG9iamVjdCBhbmQgY2FuIGNvbnZlcnQgaXQgc3RyaW5nIGxpa2UgRm9ybURhdGEgZG8uIFRoZW4geW91IGNhbiBzZW5kIHRoaXMgc3RyaW5nIGJ5IEFqYXggb3IgZG8gc29tZSBvdGhlciBzdGFmZi5cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRm9ybURhdGFcclxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBvYmplY3Qgd2l0aCBkYXRhIChzdXBwb3J0cyBuZXN0ZWQgb2JqZWN0cylcclxuICogQHBhcmFtIHtTdHJpbmd9IFtib3VuZGFyeV0gYm91bmRhcnkgIGZvciBGb3JtIERhdGFcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBmb3JtRGF0YSA9IG5ldyBMaWtlRm9ybURhdGEoe3Rlc3RLZXk6XCJ0ZXN0VmFsdWVcIn0sXCJ0ZXN0Qm91bmRhcnlcIik7XHJcbiAqIGZvcm1EYXRhLnRvU3RyaW5nKCk7XHJcbiAqIC8vIFJldHVybnM6XHJcbiAqIC8vXCItLXRlc3RCb3VuZGFyeVxyXG4gKiAvL0NvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT10ZXN0S2V5XHJcbiAqIC8vXHJcbiAqIC8vIHRlc3RWYWx1ZVxyXG4gKiAvLy0tdGVzdEJvdW5kYXJ5LS1cclxuICogLy9cIlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgZm9ybURhdGEgPSBuZXcgTGlrZUZvcm1EYXRhKHt0ZXN0S2V5OlwidGVzdFZhbHVlXCJ9KTtcclxuICogZm9ybURhdGEudG9TdHJpbmcoKTtcclxuICogLy8gUmV0dXJuczpcclxuICogLy9cIi0tU3BpcmFsRm9ybURhdGEtNDkzNTMwOTA4NTk5NDk1OVxyXG4gKiAvL0NvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT10ZXN0S2V5XHJcbiAqIC8vXHJcbiAqIC8vIHRlc3RWYWx1ZVxyXG4gKiAvLy0tU3BpcmFsRm9ybURhdGEtNDkzNTMwOTA4NTk5NDk1OS0tXHJcbiAqIC8vXCJcclxuICpcclxuICogQGV4YW1wbGVcclxuICogdmFyIGZvcm1EYXRhID0gbmV3IExpa2VGb3JtRGF0YSh7dGVzdEtleTpcInRlc3RWYWx1ZVwifSk7XHJcbiAqIGZvcm1EYXRhLmFwcGVuZChcImtleTJcIixcInZhbDJcIik7XHJcbiAqIGZvcm1EYXRhLnRvU3RyaW5nKCk7XHJcbiAqIC8vIFJldHVybnM6XHJcbiAqIC8vLS1TcGlyYWxGb3JtRGF0YS05ODg2ODEzODQ1OTUxMTFcclxuICogLy9Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9dGVzdEtleVxyXG4gKiAvL1xyXG4gKiAvL3Rlc3RWYWx1ZVxyXG4gKiAvLy0tU3BpcmFsRm9ybURhdGEtOTg4NjgxMzg0NTk1MTExXHJcbiAqIC8vQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPWtleTJcclxuICogLy9cclxuICogLy92YWwyXHJcbiAqIC8vLS1TcGlyYWxGb3JtRGF0YS05ODg2ODEzODQ1OTUxMTEtLVxyXG4gKiAvL1wiXHJcbiAqL1xyXG52YXIgTGlrZUZvcm1EYXRhID0gZnVuY3Rpb24gKGRhdGEsIGJvdW5kYXJ5KSB7XHJcbiAgICB0aGlzLmRhdGEgPSB7fTtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikgey8vbm9uIG9iamVjdC8gQWxlcnQgZGV2ZWxvcGVyXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxpa2VGb3JtRGF0YSBjYW4ndCBhY2NlcHQgbm9uIE9iamVjdC4gUGxlYXNlIHJlZWZlciB0byBkb2N1bWVudGF0aW9uLiBQcm9ibGVtIHBhcmFtZXRlciBpczpcIiwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmJvdW5kYXJ5ID0gKGJvdW5kYXJ5KSA/IGJvdW5kYXJ5IDogKFwiU3BpcmFsRm9ybURhdGEtXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIpKTtcclxuXHJcblxyXG4gICAgLy9pZiAoIWlzT2xkSUUpIHtcclxuICAgIC8vICAgIHRoaXMuYm91bmRhcnkgPSBcIlNwaXJhbEFqYXgtXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIpO1xyXG4gICAgLy8gICAgLy94aHIuc2V0UmVxdWVzdEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGE7IGNoYXJzZXQ9dXRmLTg7IGJvdW5kYXJ5PVwiICsgdGhpcy5ib3VuZGFyeSk7XHJcbiAgICAvL30gZWxzZSB7XHJcbiAgICAvLyAgICB0aGlzLmJvdW5kYXJ5ID0gXCJTcGlyYWxBamF4LW9sZElFOTg3NmdzbG9pSEdsZG93dVwiO1xyXG4gICAgLy99XHJcblxyXG59O1xyXG4vKipcclxuICogQXBwZW5kIGRhdGEgdG8gc3RvcmFnZS4gTGlrZSBzdGFuZGFydCBGb3JtRGF0YSBkby5cclxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gKiBmb3JtRGF0YS5hcHBlbmQoXCJrZXkyXCIsXCJ2YWwyXCIpO1xyXG4gKi9cclxuTGlrZUZvcm1EYXRhLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcclxuICAgIC8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Zvcm1EYXRhXHJcbiAgICAvL1RPRE8gKioqQXBwZW5kcyBhIG5ldyB2YWx1ZSoqKiogb250byBhbiBleGlzdGluZyBrZXkgaW5zaWRlIGEgRm9ybURhdGEgb2JqZWN0LCBvciBhZGRzIHRoZSBrZXkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cclxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNvbnZlcnQgdG8gc3RyaW5nXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBmb3JtRGF0YSA9IG5ldyBMaWtlRm9ybURhdGEoe3Rlc3RLZXk6XCJ0ZXN0VmFsdWVcIn0pO1xyXG4gKiBmb3JtRGF0YS50b1N0cmluZygpO1xyXG4gKiAvLyBSZXR1cm5zOlxyXG4gKiAvL1wiLS1TcGlyYWxGb3JtRGF0YS00OTM1MzA5MDg1OTk0OTU5XHJcbiAqIC8vQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPXRlc3RLZXlcclxuICogLy9cclxuICogLy8gdGVzdFZhbHVlXHJcbiAqIC8vLS1TcGlyYWxGb3JtRGF0YS00OTM1MzA5MDg1OTk0OTU5LS1cclxuICogLy9cIlxyXG4gKi9cclxuTGlrZUZvcm1EYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciByZXRTdHJpbmcgPSBcIlwiO1xyXG4gICAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5ib3VuZGFyeTtcclxuICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBhcnRPZktleSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkgJiYgKHR5cGVvZiBkYXRhW2tleV0gIT09IFwidW5kZWZpbmVkXCIgKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tleV0gPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKGRhdGFba2V5XSwgKChwYXJ0T2ZLZXkubGVuZ3RoID09PSAwKSA/IGtleSA6IChwYXJ0T2ZLZXkgKyBcIltcIiArIGtleSArIFwiXVwiKSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRTdHJpbmcgKz0gXCItLVwiICsgYm91bmRhcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBcIlxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiArICgocGFydE9mS2V5Lmxlbmd0aCA9PT0gMCkgPyBrZXkgOiAocGFydE9mS2V5ICsgXCJbXCIgKyBrZXkgKyBcIl1cIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCJcXHJcXG5cXHJcXG5cIiArIGRhdGFba2V5XSArIFwiXFxyXFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSB7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGl0ZXJhdGUodGhpcy5kYXRhLCBcIlwiKTtcclxuXHJcblxyXG4gICAgcmV0U3RyaW5nICs9IFwiLS1cIiArIHRoaXMuYm91bmRhcnkgKyBcIi0tXFxyXFxuXCI7XHJcbiAgICByZXR1cm4gcmV0U3RyaW5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkZWxldGUoKSBtZXRob2Qgb2YgdGhlIEZvcm1EYXRhIGludGVyZmFjZSBkZWxldGVzIGEga2V5L3ZhbHVlIHBhaXIgZnJvbSBhIEZvcm1EYXRhIG9iamVjdC5cclxuICogQHBhcmFtIGtleVxyXG4gKi9cclxuTGlrZUZvcm1EYXRhLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gZGVsZXRlKHRoaXMuZGF0YVtrZXldKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICpUaGUgZ2V0KCkgbWV0aG9kIG9mIHRoZSBGb3JtRGF0YSBpbnRlcmZhY2UgcmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5IGZyb20gd2l0aGluIGEgRm9ybURhdGEgb2JqZWN0LlxyXG4gKiBAcGFyYW0ga2V5XHJcbiAqL1xyXG5MaWtlRm9ybURhdGEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcclxufTtcclxuLyoqXHJcbiAqVGhlIGdldEFsbCgpIG1ldGhvZCBvZiB0aGUgRm9ybURhdGEgaW50ZXJmYWNlIHJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleSBmcm9tIHdpdGhpbiBhIEZvcm1EYXRhIG9iamVjdC5cclxuICovXHJcbkxpa2VGb3JtRGF0YS5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgaGFzKCkgbWV0aG9kIG9mIHRoZSBGb3JtRGF0YSBpbnRlcmZhY2UgcmV0dXJucyBhIGJvb2xlYW4gc3RhdGluZyB3aGV0aGVyIGEgRm9ybURhdGEgb2JqZWN0IGNvbnRhaW5zIGEgY2VydGFpbiBrZXkvdmFsdWUgcGFpci5cclxuICogQHBhcmFtIGtleVxyXG4gKi9cclxuTGlrZUZvcm1EYXRhLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpe1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc2V0KCkgYW5kIEZvcm1EYXRhLmFwcGVuZCBpcyB0aGF0IGlmIHRoZSBzcGVjaWZpZWQgaGVhZGVyIGRvZXMgYWxyZWFkeSBleGlzdCwgc2V0KCkgd2lsbCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlIHdpdGggdGhlIG5ldyBvbmUsIHdoZXJlYXMgRm9ybURhdGEuYXBwZW5kIHdpbGwgYXBwZW5kIHRoZSBuZXcgdmFsdWUgb250byB0aGUgZW5kIG9mIHRoZSBzZXQgb2YgdmFsdWVzLlxyXG4gKiBAcGFyYW0ga2V5XHJcbiAqIEBwYXJhbSB2YWxcclxuICovXHJcbkxpa2VGb3JtRGF0YS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpe1xyXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWw7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGNvbnRlbnQgaGVhZGVyIHRvIHNldCBmb3IgQWpheC4gTm90IGEgcGFydCBvZiBzdGFuZGFydCBGb3JtRGF0YSBvYmplY3QuIEJ1dCBmb3Igc2VuZGluZyBMaWtlIEZvcm1EYXRhIG92ZXIgQWpheCB5b3Ugc2hvdWxkIGtub3cgaGVhZGVyLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBmb3JtRGF0YSA9IG5ldyBMaWtlRm9ybURhdGEoKTtcclxuICogZm9ybURhdGEuZ2V0Q29udGVudFR5cGVIZWFkZXIoKTsgLy9yZXR1cm4gXCJtdWx0aXBhcnQvZm9ybS1kYXRhOyBjaGFyc2V0PXV0Zi04OyBib3VuZGFyeT1TcGlyYWxGb3JtRGF0YS05ODg2ODEzODQ1OTUxMTFcIlxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgZm9ybURhdGEgPSBuZXcgTGlrZUZvcm1EYXRhKHtrZXk6XCJ2YWwyXCJ9LFwidGVzdEJvdW5kYXJ5XCIpO1xyXG4gKiBmb3JtRGF0YS5nZXRDb250ZW50VHlwZUhlYWRlcigpOyAvL3JldHVybiBcIm11bHRpcGFydC9mb3JtLWRhdGE7IGNoYXJzZXQ9dXRmLTg7IGJvdW5kYXJ5PXRlc3RCb3VuZGFyeVwiXHJcbiAqL1xyXG5MaWtlRm9ybURhdGEucHJvdG90eXBlLmdldENvbnRlbnRUeXBlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YTsgY2hhcnNldD11dGYtODsgYm91bmRhcnk9XCIgKyB0aGlzLmJvdW5kYXJ5O1xyXG5cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpa2VGb3JtRGF0YTsiLCIvKipcclxuIFRoaXMgaXMgYSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBET00gdG9vbHMuXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3VuZCBmaXJzdCBwYXJlbnQgbm9kZSB3aXRoIG1hdGNoZWQgc2VsZWN0b3IocylcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIC0gZG9tIG5vZGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBzZWxlY3RvcnMgLSBzZWxlY3RvciBvciBhcnJheSBvZiBzZWxlY3RvcnNcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8IEJvb2xlYW59IC0gbm9kZSBvciBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgY2xvc2VzdDogZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9ycykge1xyXG4gICAgICAgIHNlbGVjdG9ycyA9ICh0eXBlb2Ygc2VsZWN0b3JzID09PSAnc3RyaW5nJykgPyBbc2VsZWN0b3JzXSA6IHNlbGVjdG9ycztcclxuICAgICAgICB2YXIga2V5LFxyXG4gICAgICAgICAgICBsID0gc2VsZWN0b3JzLmxlbmd0aCxcclxuICAgICAgICAgICAgbWF0Y2hlc1NlbGVjdG9yID0gZWxlbS5tYXRjaGVzIHx8IGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW0ubXNNYXRjaGVzU2VsZWN0b3I7XHJcbiAgICAgICAgd2hpbGUgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIGZvciAoa2V5ID0gMDsga2V5IDwgbDsga2V5KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzU2VsZWN0b3IuY2FsbChlbGVtLCBzZWxlY3RvcnNba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3VuZCBmaXJzdCBwYXJlbnQgbm9kZSB3aXRoIG1hdGNoZWQgY2xhc3NOYW1lKHMpLlxyXG4gICAgICogVE9ETyBXaHkgdGhpcz8gQmVjYXVzZSBvbGQgSUUuLi4uXHJcbiAgICAgKiBUT0RPIEl0J3Mgbm90IGdvb2QsIGJlY2F1c2UgaXQncyBhIGNvcHkgb2YgY2xvc2VzdCBAc2VlIGNsb3Nlc3QuIFJlZmFjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSAtIGRvbSBub2RlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gY2xhc3NOYW1lIC0gY2xhc3NOYW1lIG9yIGFycmF5IG9mIGNsYXNzTmFtZXNcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8IEJvb2xlYW59IC0gbm9kZSBvciBmYWxzZVxyXG4gICAgICovXHJcblxyXG4gICAgY2xvc2VzdEJ5Q2xhc3NOYW1lOiBmdW5jdGlvbiAoZWxlbSwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgY2xhc3NOYW1lID0gKHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSA/IFtjbGFzc05hbWVdIDogY2xhc3NOYW1lO1xyXG4gICAgICAgIHZhciBrZXksXHJcbiAgICAgICAgICAgIGwgPSBjbGFzc05hbWUubGVuZ3RoO1xyXG4gICAgICAgIC8vLG1hdGNoZXNTZWxlY3RvciA9IGVsZW0ubWF0Y2hlcyB8fCBlbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbGVtLm1zTWF0Y2hlc1NlbGVjdG9yO1xyXG4gICAgICAgIHdoaWxlIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBmb3IgKGtleSA9IDA7IGtleSA8IGw7IGtleSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lW2tleV0gKyBcIihcXFxcc3wkKVwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLmNsYXNzTmFtZS5tYXRjaChyZWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgdG9vbHNcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHRvb2xzID0ge1xyXG4gICAgcmVzb2x2ZUtleVBhdGggOiBmdW5jdGlvbihwYXRoLCBvYmosIHNhZmUpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhc2FmZSA/IHByZXZbY3Vycl0gOiAocHJldiA/IHByZXZbY3Vycl0gOiB2b2lkIDApXHJcbiAgICAgICAgfSwgb2JqfHxzZWxmKVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0b29sczsiLCJcInVzZSBzdHJpY3RcIjtcclxuLy9odHRwczovL2dpdGh1Yi5jb20vc3BpcmFsL3NmLmpzXHJcblxyXG4vL0FkZCBjb25zb2xlIHNoaW0gZm9yIG9sZCBJRVxyXG5yZXF1aXJlKFwiLi9zaGltL2NvbnNvbGVcIik7XHJcbnJlcXVpcmUoXCIuL3NoaW0vT2JqZWN0LmFzc2lnblwiKTtcclxuaWYgKHR5cGVvZiBQcm9taXNlICE9ICdmdW5jdGlvbicpIHtcclxuICAgIHZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xyXG59XHJcblxyXG52YXIgX3NmO1xyXG5cclxuaWYgKHR5cGVvZiBzZiAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNmKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xyXG4gICAgX3NmID0gT2JqZWN0LmFzc2lnbihzZiwgcmVxdWlyZShcIi4vc2ZcIikpO1xyXG59IGVsc2Uge1xyXG4gICAgX3NmID0gcmVxdWlyZShcIi4vc2ZcIik7XHJcbn1cclxuXHJcbmlmICghX3NmLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIF9zZi5vcHRpb25zID0ge2luc3RhbmNlczp7fX07XHJcbmlmICghX3NmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2luc3RhbmNlcycpKSBfc2Yub3B0aW9ucy5pbnN0YW5jZXMgPSB7fTtcclxuXHJcbi8vdG9kbyBkZWxldGUgdGhpcyBpbiBmdXR1cmVcclxuaWYgKCF3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJzZlwiKSkgey8vYmluZCBvbmx5IGlmICB3aW5kb3cuc2YgaXMgZW1wdHkgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgbGlic1xyXG4gICAgd2luZG93LnNmID0gX3NmO1xyXG59XHJcblxyXG5fc2YuaW5zdGFuY2VzQ29udHJvbGxlciA9IG5ldyBfc2YuY29yZS5JbnN0YW5jZXNDb250cm9sbGVyKHNmKTtcclxuX3NmLmRvbU11dGF0aW9uID0gbmV3IF9zZi5jb3JlLkRvbU11dGF0aW9ucyhfc2YuaW5zdGFuY2VzQ29udHJvbGxlcik7XHJcblxyXG4vL0V2ZW50cyBzeXN0ZW1cclxuX3NmLmV2ZW50cyA9IG5ldyBfc2YuY29yZS5FdmVudHMoKTtcclxucmVxdWlyZShcIi4vY29yZS9ldmVudHMvYmFzZUV2ZW50cy5qc1wiKShfc2YuZXZlbnRzKTtcclxuXHJcbi8vQUpBWFxyXG5fc2YuYWpheCA9IG5ldyBfc2YuY29yZS5BamF4KHdpbmRvdy5jc3JmVG9rZW4gPyB7Ly9UT0RPIG1vdmUgdG8gc3BpcmFsIGJpbmRpbmdzXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgXCJYLUNTUkYtVG9rZW5cIjogd2luZG93LmNzcmZUb2tlblxyXG4gICAgfVxyXG59IDogbnVsbCk7XHJcbnJlcXVpcmUoXCIuL2NvcmUvYWpheC9iYXNlQWN0aW9ucy5qc1wiKShfc2YpO1xyXG5cclxuLy9BUElcclxuX3NmLmNyZWF0ZU1vZHVsZVByb3RvdHlwZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShfc2YubW9kdWxlcy5jb3JlLkJhc2VET01Db25zdHJ1Y3Rvci5wcm90b3R5cGUpfTtcclxuX3NmLnJlZ2lzdGVySW5zdGFuY2VUeXBlID0gX3NmLmluc3RhbmNlc0NvbnRyb2xsZXIucmVnaXN0ZXJJbnN0YW5jZVR5cGUuYmluZChfc2YuaW5zdGFuY2VzQ29udHJvbGxlcik7XHJcbl9zZi5hZGRJbnN0YW5jZSA9IF9zZi5pbnN0YW5jZXNDb250cm9sbGVyLmFkZEluc3RhbmNlLmJpbmQoX3NmLmluc3RhbmNlc0NvbnRyb2xsZXIpO1xyXG5fc2YucmVtb3ZlSW5zdGFuY2UgPSBfc2YuaW5zdGFuY2VzQ29udHJvbGxlci5yZW1vdmVJbnN0YW5jZS5iaW5kKF9zZi5pbnN0YW5jZXNDb250cm9sbGVyKTtcclxuX3NmLmdldEluc3RhbmNlID0gX3NmLmluc3RhbmNlc0NvbnRyb2xsZXIuZ2V0SW5zdGFuY2UuYmluZChfc2YuaW5zdGFuY2VzQ29udHJvbGxlcik7XHJcbl9zZi5nZXRJbnN0YW5jZXMgPSBfc2YuaW5zdGFuY2VzQ29udHJvbGxlci5nZXRJbnN0YW5jZXMuYmluZChfc2YuaW5zdGFuY2VzQ29udHJvbGxlcik7XHJcblxyXG5fc2YuY2xvc2VzdCA9IHNmLmhlbHBlcnMuZG9tVG9vbHMuY2xvc2VzdDtcclxuX3NmLnJlc29sdmVLZXlQYXRoID0gc2YudG9vbHMucmVzb2x2ZUtleVBhdGg7XHJcblxyXG5pZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfc2Y7XHJcbn0iLCJ2YXIgY29yZSA9IHtcclxuICAgIEFqYXg6IHJlcXVpcmUoXCIuL2NvcmUvQWpheFwiKSxcclxuICAgIEJhc2VET01Db25zdHJ1Y3RvcjogcmVxdWlyZShcIi4vY29yZS9CYXNlRE9NQ29uc3RydWN0b3JcIiksXHJcbiAgICBEb21NdXRhdGlvbnM6IHJlcXVpcmUoXCIuL2NvcmUvRG9tTXV0YXRpb25zXCIpLFxyXG4gICAgRXZlbnRzOiByZXF1aXJlKFwiLi9jb3JlL0V2ZW50c1wiKSxcclxuICAgIEluc3RhbmNlc0NvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL2NvcmUvSW5zdGFuY2VzQ29udHJvbGxlclwiKVxyXG59O1xyXG5cclxudmFyIGhlbHBlcnMgPSB7XHJcbiAgICBET01FdmVudHM6IHJlcXVpcmUoXCIuL2hlbHBlcnMvRE9NRXZlbnRzXCIpLFxyXG4gICAgZG9tVG9vbHM6IHJlcXVpcmUoXCIuL2hlbHBlcnMvZG9tVG9vbHNcIiksXHJcbiAgICBMaWtlRm9ybURhdGE6IHJlcXVpcmUoXCIuL2hlbHBlcnMvTGlrZUZvcm1EYXRhXCIpLFxyXG4gICAgdG9vbHM6IHJlcXVpcmUoXCIuL2hlbHBlcnMvdG9vbHNcIilcclxufTtcclxuXHJcbnZhciBzZiA9IHtcclxuICAgIGNvcmU6IGNvcmUsXHJcbiAgICBoZWxwZXJzOiBoZWxwZXJzLFxyXG4gICAgdG9vbHM6IGhlbHBlcnMudG9vbHMsXHJcbiAgICBtb2R1bGVzOiB7Ly90b2RvIHJlbW92ZSB0aGlzIHdoZW4gcmVtb3ZlZCBpbiBkZXBlbmRlbmNpZXNcclxuICAgICAgICAnV0lMTF9CRV9ERVBSRUNBVEVEJzogdHJ1ZSxcclxuICAgICAgICBjb3JlOiBjb3JlLFxyXG4gICAgICAgIGhlbHBlcnM6IGhlbHBlcnNcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2Y7IiwiLyoqXHJcbiAqIE9iamVjdC5hc3NpZ24gcG9seWZpbGxcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxyXG4gKi9cclxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9ICdmdW5jdGlvbicpIHtcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbn0iLCIvKipcclxuICogQXZvaWQgYGNvbnNvbGVgIGVycm9ycyBpbiBicm93c2VycyB0aGF0IGxhY2sgYSBjb25zb2xlLlxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtZXRob2QsIG5vb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRob2RzID0gW1xyXG4gICAgICAgICAgICAnYXNzZXJ0JywgJ2NsZWFyJywgJ2NvdW50JywgJ2RlYnVnJywgJ2RpcicsICdkaXJ4bWwnLCAnZXJyb3InLFxyXG4gICAgICAgICAgICAnZXhjZXB0aW9uJywgJ2dyb3VwJywgJ2dyb3VwQ29sbGFwc2VkJywgJ2dyb3VwRW5kJywgJ2luZm8nLCAnbG9nJyxcclxuICAgICAgICAgICAgJ21hcmtUaW1lbGluZScsICdwcm9maWxlJywgJ3Byb2ZpbGVFbmQnLCAndGFibGUnLCAndGltZScsICd0aW1lRW5kJyxcclxuICAgICAgICAgICAgJ3RpbWVTdGFtcCcsICd0cmFjZScsICd3YXJuJ1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGgsXHJcbiAgICAgICAgY29uc29sZSA9ICh3aW5kb3cuY29uc29sZSA9IHdpbmRvdy5jb25zb2xlIHx8IHt9KTtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICBtZXRob2QgPSBtZXRob2RzW2xlbmd0aF07XHJcblxyXG4gICAgICAgIC8vIE9ubHkgc3R1YiB1bmRlZmluZWQgbWV0aG9kcy5cclxuICAgICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlW21ldGhvZF0gPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSgpKTtcclxuIl19"}